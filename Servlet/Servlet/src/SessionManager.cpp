//
// SessionManager.cpp
//
//
// Library: ServletEx
// Package: Servlet
// Module:  SessionManager
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Servlet/Ex/SessionManager.h"
#include "Poco/Servlet/HttpSession.h"
#include "Poco/Mutex.h"
#include "Poco/Timer.h"
#include "Poco/Exception.h"


namespace Poco {
namespace Servlet {
namespace Ex {


Poco::Mutex SessionManager::_mutex;


SessionManager::SessionManager(long maxInactiveInterval,
	HttpSessionListener* pSessionListener,
	long maxSessions,
	long purgeInterval):
	_maxInactiveInterval(maxInactiveInterval),
	_maxSessions(maxSessions),
	_pTimer(new Timer(purgeInterval*1000, purgeInterval*1000)), 
	_pCallback(new TimerCallback<SessionManager>(*this, &SessionManager::onTimer)),
	_pSessionListener(pSessionListener)
{
	if(_pTimer && _pCallback) _pTimer->start(*_pCallback);
	else 
	{
		delete _pTimer;
		delete _pCallback;
		throw NullPointerException("Timer could not be started.");
	}
}


SessionManager::~SessionManager()
{
	if(_pTimer) _pTimer->stop();
	delete _pTimer;
	delete _pCallback;

	invalidateAllSessions();
	destroyAllSessions();
}


bool SessionManager::exists(const std::string& id) const
{
	return (_sessionMap.find(id)!= _sessionMap.end());
}


bool SessionManager::isValid(const std::string& id) const
{
	if(!exists(id)) return false;

	HttpSession* ps = _sessionMap.find(id)->second;

	if(ps) return ps->isValidNS();

	return false;
}


const HttpSession& SessionManager::makeSession()
{
	try
	{
		if (_sessionMap.size() < _maxSessions)
			return newSession(_maxInactiveInterval);
		else 
			throw RuntimeException("Maximum number of sessions reached.");
	}
	catch(...)
	{
		throw;
	}
}


const HttpSession& SessionManager::session(const std::string& id)
{
	if("" == id)
		throw InvalidArgumentException("Session ID required");

	Mutex::ScopedLock l(_mutex);

	SessionMap::const_iterator it = _sessionMap.find(id);

	if(it != _sessionMap.end()) 
	{
		if(it->second) 
		{
			if(it->second->isValidNS())	
			{
				it->second->setLastAccessedTimeNS(time(0));
				return *(it->second);
			}
			else throw InvalidArgumentException("Invalid session: " + id);
		}
		else throw NullPointerException("SessionManager::getSession");
	}
	else throw NotFoundException("SessionManager::getSession");
}


bool SessionManager::destroySession(const std::string& id)
{
	Mutex::ScopedLock l(_mutex);
	SessionMap::iterator it = _sessionMap.find(id);
	if(it != _sessionMap.end())
	{
		delete it->second;
		_sessionMap.erase(id);
		return true;
	}
	else return false;
}


void SessionManager::invalidateAllSessions()
{
	Mutex::ScopedLock l(_mutex);
	SessionMap::iterator it = _sessionMap.begin();
	for(; it != _sessionMap.end(); ++it)
	{
		if(it->second) it->second->invalidate();
	}
}


void SessionManager::destroyAllSessions()
{
	Mutex::ScopedLock l(_mutex);
	SessionMap::iterator it = _sessionMap.begin();
	for(; it != _sessionMap.end(); )
	{
		delete it->second;
		_sessionMap.erase(it++);
	}
}


void SessionManager::onTimer(Poco::Timer& timer)
{
	Mutex::ScopedLock l(_mutex);
	SessionMap::iterator it = _sessionMap.begin();
	for(; it != _sessionMap.end(); )
	{
		if(it->second)
		{
			if(!it->second->isValidNS()) 
			{
				delete it->second;
				_sessionMap.erase(it++);
			}
			else ++it;
		}
	}
}


} } } // namespace Poco::Servlet::Ex
