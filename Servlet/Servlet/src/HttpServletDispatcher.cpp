//
// HttpServletDispatcher.cpp
//
//
// Library: ServletEx
// Package: Http
// Module:  HttpServletDispatcher
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Servlet/Ex/HttpServletDispatcher.h"
#include "Poco/Servlet/Ex/ServletProvider.h"
#include "Poco/Servlet/Ex/PathMapping.h"
#include "Poco/Servlet/Ex/SystemFiles.h"
#include "Poco/Servlet/Servlet.h"
#include "Poco/Servlet/ServletRequest.h"
#include "Poco/Servlet/ServletResponse.h"
#include "Poco/File.h"
#include "Poco/Path.h"
#include "Poco/Mutex.h"
#include "Poco/Timestamp.h"
#include "Poco/StreamCopier.h"
#include "Poco/DateTimeFormatter.h"
#include "Poco/DateTimeFormat.h"
#include "Poco/Exception.h"
#include <string>
#include <fstream>


namespace Poco {
namespace Servlet {
namespace Ex {


HttpServletDispatcher::HttpServletDispatcher(FilterDispatcher* pFilterDispatcher, SessionManager* pSessionManager):
	ServletDispatcher(pSessionManager), 
	_pFilterDispatcher(pFilterDispatcher)
{
}


HttpServletDispatcher::~HttpServletDispatcher()
{
}


bool HttpServletDispatcher::isStaticFileRequest(const std::string& path)
{
	std::string servletPath = path;
	std::string ctxName = PathMapping::splitPath(servletPath);
	std::string servletName = resolve(ctxName, servletPath);
	
	std::string context = contextName(path);
	ServletContext* psc =  getContext(context);
	poco_check_ptr(psc);
	std::string fileName = psc->getRealPath(servletPath);
	
	bool isFile = Path(fileName).isFile();
	// Empty servletName means that no servlet has been registered 
	// for the files of this type.
	bool noServlet = ("" == servletName);
	bool isDefaultServlet = (getDefaultServlet(ctxName) == servletName);
	return (isFile && (noServlet || isDefaultServlet));
}


void HttpServletDispatcher::dispatch(ServletRequest& req, ServletResponse& res, const std::string& path)
{
	Mutex::ScopedLock lock(_mutex);

	HttpServletRequest* pRequest = dynamic_cast<HttpServletRequest *>(&req);
	poco_check_ptr(pRequest);
	HttpServletRequest& request = *pRequest;

	HttpServletResponse* pResponse = dynamic_cast<HttpServletResponse *>(&res);
	poco_check_ptr(pResponse);
	HttpServletResponse& response = *pResponse;

	std::string servletPath = ("" != path) ? path : request.getServletPath();

	if(!isSystemFileRequest(request))
	{
		std::string ctxName = contextName(servletPath);

		if(("" != ctxName) && isRegistered(ctxName))
		{
			try
			{
				if (isStaticFileRequest(servletPath))
				{
					try
					{
						ServletContext* psc = getContext(ctxName);
						if (psc)
						{
							PathMapping::splitPath(servletPath);
							handleFileRequest(psc->getRealPath(servletPath), response);
						}
						else throw NotFoundException();
					}
					catch(OpenFileException&)
					{
						throw OpenFileException(servletPath);
					}
				}
				else
				{
					ServletContext* psc = getContext(ctxName);
					if (psc) handleServletRequest(psc, request, response, servletPath);
					else throw NotFoundException();
				}
			}
			catch(NotFoundException&)
			{
				throw NotFoundException(servletPath);
			}
		}
		else
		{
			throw InvalidArgumentException("HttpServletDispatcher::dispatch: [" + ctxName + "] context not found");
		}
	}
	else
	{
		throw InvalidArgumentException("HttpServletDispatcher::dispatch - forbidden.");
	}
}


bool HttpServletDispatcher::isSystemFileRequest(HttpServletRequest& request)
{
	// Filter out attempts to reach for config or system files.
	std::string path = Path(request.getServletPath(), Path::PATH_UNIX).toString(Path::PATH_UNIX);
	std::string webInfXML = SystemFiles::WEB_INF_DIR + '/' + SystemFiles::WEB_XML_FILE;
	std::string webInfClass = SystemFiles::WEB_INF_DIR + '/' + SystemFiles::CLASS_DIR;
	std::string webInfLib = SystemFiles::WEB_INF_DIR + '/' + SystemFiles::LIB_DIR;

	return ((path.find(webInfXML) != path.npos) ||
			(path.find(webInfClass) != path.npos) ||
			(path.find(webInfLib) != path.npos));
}


void HttpServletDispatcher::handleFileRequest(const std::string& abspath, HttpServletResponse& response)
{
	Path p(abspath);	
	File f(p.toString());
	if(f.exists())
	{
		Timestamp dateTime    = f.getLastModified();
		File::FileSize length = f.getSize();
		response.setDateHeader("Date", dateTime.epochTime());
		response.setContentLength((int) length);
		response.setHeader("Last-Modified", 
			DateTimeFormatter::format(f.getLastModified(), DateTimeFormat::ISO8601_FORMAT));
		std::string extension = f.path();
		std::string mediaType = mimeType(extension.substr(f.path().find_last_of('.')+1));
		if("" != mediaType) response.setContentType(mediaType);

		std::ifstream istr(abspath.c_str(), std::ios::binary | std::ios::in);
		if (istr.good())
		{
			StreamCopier::copyStream(istr, response.getOutputStream());
		}
		else throw OpenFileException();
	}
	else throw NotFoundException();
}


void HttpServletDispatcher::handleServletRequest(ServletContext* psc, 
	HttpServletRequest& request, 
	HttpServletResponse& response,
	const std::string& path)
{
	std::string servletPath;
	if("" == path)	servletPath = request.getServletPath();
	else			servletPath = path;
	std::string ctxName = PathMapping::splitPath(servletPath);
	std::string servletName = resolve(ctxName, servletPath);

	const HttpSession* pSession = 0;

	if(("" != psc->getInitParameter("session-config.session-timeout")))
	{
		pSession = request.getSession();
		poco_check_ptr(pSession);

		std::string sessionId = pSession->getId();

		servletName += ServletProvider::NAME_SEPARATOR;
		servletName += sessionId;
	}
	
	Servlet* ps = getServlet(ctxName, servletName);
	poco_check_ptr(ps);

	if(_pFilterDispatcher)	_pFilterDispatcher->dispatch(*ps, request, response);
	else					ps->service(request, response);
}


std::string HttpServletDispatcher::mimeType(const std::string& extension) const
{
	MimeMap::const_iterator it = _mimeMap.find(extension);
	if (_mimeMap.end() != it) return it->second;

	return "";
}


const MimeMap& HttpServletDispatcher::getMimeMap() const
{
	return _mimeMap;
}


} } } // namespace Poco::Servlet::Ex
