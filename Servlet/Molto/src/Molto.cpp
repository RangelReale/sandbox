//
// Molto.cpp
//
// Application: Molto
// Package:     MoltoCore
// Module:      Molto
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Molto.h"
#include "Poco/Servlet/Container/WebContainer.h"
#include "Poco/Util/ServerApplication.h"
#include "Poco/Util/AbstractConfiguration.h"
#include "Poco/Util/Option.h"
#include "Poco/Util/OptionSet.h"
#include "Poco/Util/HelpFormatter.h"
#include "Poco/Util/LoggingConfigurator.h"
#include "Poco/Util/PropertyFileConfiguration.h"
#include "Poco/Util/LayeredConfiguration.h"
#include "Poco/Util/SystemConfiguration.h"
#include "Poco/AutoPtr.h"
#include "Poco/Thread.h"
#include "Poco/SplitterChannel.h"
#include "Poco/Exception.h"
#include <iostream>
#include <sstream>


#ifdef _MSC_VER
#	include <direct.h>
#	define chdir _chdir
#endif


using Poco::Util::AbstractConfiguration;
using Poco::Util::PropertyFileConfiguration;
using Poco::Util::LayeredConfiguration;
using Poco::Util::SystemConfiguration;
using Poco::Util::LoggingConfigurator;
using Poco::Util::HelpFormatter;
using Poco::Util::Option;
using Poco::Util::OptionSet;
using Poco::AutoPtr;
using Poco::Logger;
using Poco::SplitterChannel;
using Poco::Thread;
using Poco::NotFoundException;
using Poco::Servlet::Container::WebContainer;


Molto::Molto(): _helpRequested(false)
{
}


Molto::~Molto()
{
}


void Molto::initialize(Application& self)
{
	loadConfiguration(); // load default configuration files, if present
	ServerApplication::initialize(self);
	
	if("" == _rootDir) 
		  _rootDir = config().getString("application.dir");

	chdir(_rootDir.c_str());
	initLogging();
}


void Molto::uninitialize()
{
	logger().information("shutting down");
	ServerApplication::uninitialize();
}


void Molto::defineOptions(OptionSet& options)
{
	ServerApplication::defineOptions(options);
	
	options.addOption(
		Option("help", "h", "display help information on command line arguments")
			.required(false)
			.repeatable(false));

	options.addOption(
		Option("wdir", "w", "specifies application working directory (if omitted, defaults to the directory where the executable resides)")
			.required(false)
			.repeatable(false)
			.argument("directory"));
}


void Molto::handleOption(const std::string& name, const std::string& value)
{
	ServerApplication::handleOption(name, value);

	if (name == "help")
	  _helpRequested = true;
	else if (name == "wdir")
	  _rootDir = value;
}


void Molto::displayHelp()
{
	HelpFormatter helpFormatter(options());
	helpFormatter.setCommand(commandName());
	helpFormatter.setUsage("OPTIONS");
	helpFormatter.setHeader("A servlet container/server application.");
	helpFormatter.format(std::cout);
}


void Molto::initLogging()
{
	std::string logFile = _rootDir + config().getString("log.properties");

	AutoPtr<LayeredConfiguration> pLC = new LayeredConfiguration;
	SystemConfiguration* pSC = new SystemConfiguration;
	PropertyFileConfiguration* pPFC = new PropertyFileConfiguration(logFile);

	pLC->add(pPFC);
	pLC->add(pSC);

	LoggingConfigurator configurator;
	configurator.configure(pLC);
	
	Logger& logger1 = Logger::get("logger1");
	SplitterChannel* pFC = dynamic_cast<SplitterChannel*>(logger1.getChannel());
	poco_check_ptr(pFC);
	logger().setChannel(pFC);
}


void Molto::logStartup(const std::vector<std::string>& args)
{
	logger().information("Starting up ...");
	logger().information("Arguments to main():");

	std::vector<std::string>::const_iterator it = args.begin();
	for (; it != args.end(); ++it)
		logger().information(*it);
	
	printProperties("");
	logger().information("Startup OK.");
}


void Molto::printProperties(const std::string& base)
{
	AbstractConfiguration::Keys keys;
	config().keys(base, keys);
	try
	{
		if (keys.empty())
		{
			if (config().hasProperty(base))
			{
				std::string msg;
				msg.append(base);
				msg.append(" = ");
				msg.append(config().getString(base));
				logger().information(msg);
			}
		}
		else
		{
			AbstractConfiguration::Keys::const_iterator it = keys.begin();
			for (; it != keys.end(); ++it)
			{
				std::string fullKey = base;
				if (!fullKey.empty()) fullKey += '.';
				fullKey.append(*it);
				printProperties(fullKey);
			}
		}
	}
	catch(NotFoundException e)
	{
		logger().error(e.message());
	}
}


void Molto::runContainer()
{
	WebContainer c (_rootDir,
		config().getString("webapps.dir"),
		config().getString("webservers.dir"),
		&logger());
	  
	Thread t; t.start(c);
	waitForTerminationRequest();
	c.stop(); t.join();
}


int Molto::main(const std::vector<std::string>& args)
{
	if (_helpRequested) displayHelp();
	else
	{
		logStartup(args);
		runContainer();
	}

	return Application::EXIT_OK;
}
