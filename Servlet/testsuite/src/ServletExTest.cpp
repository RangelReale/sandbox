//
// ServletExTest.cpp
//
// Library: TestSuite
// Package: Servlets
// Module:  ServletExTest
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "ServletExTest.h"
#include "CppUnit/TestCaller.h"
#include "CppUnit/TestSuite.h"
#include "Poco/Servlet/Container/ServletContextImpl.h"
#include "Poco/Servlet/Ex/PathMapping.h"
#include "Poco/Servlet/Ex/FilterDispatcher.h"
#include "Poco/Servlet/Ex/HttpServletDispatcher.h"
#include "Poco/Servlet/Ex/HttpServerConfig.h"
#include "Poco/Environment.h"
#include "Poco/Exception.h"


using Poco::Environment;
using Poco::NotFoundException;
using Poco::InvalidArgumentException;
using Poco::Servlet::Ex::FilterDispatcher;
using Poco::Servlet::Ex::HttpServerConfig;
using Poco::Servlet::Ex::HttpServletDispatcher;
using Poco::Servlet::Ex::PathMapping;
using Poco::Servlet::Container::ServletContextImpl;


ServletExTest::ServletExTest(const std::string& name): CppUnit::TestCase(name)
{
	std::string base;

  try
  {
		base = Environment::get("POCO_BASE");
  }catch(NotFoundException&)
  {
		base = ".";
  }
  
  _rootDir = base + "/Servlet/runtime/";
}


ServletExTest::~ServletExTest()
{
}


void ServletExTest::testPathMapping()
{
	testSplitPath();

	assert(_pm.resolveName("/servlet0") == "servlet0");
	assert(_pm.resolveName("/servlet1") == "servlet1");
	assert(_pm.resolveName("/servlet2") == "servlet2");
	assert(_pm.resolveName("/servlet3") == "servlet3");
	assert(_pm.resolveName("/servlet4") == "servlet4");
	assert(_pm.resolveName("/foo/bar/index.bop") == "servlet1");
	assert(_pm.resolveName("/baz") == "servlet2");
	assert(_pm.resolveName("/baz/index.html") == "servlet2");
	assert(_pm.resolveName("/catalog") == "servlet3");
	assert(_pm.resolveName("/catalog/index.html") == "servlet0");
	assert(_pm.resolveName("/catalog/racecar.bop") == "servlet4");
	assert(_pm.resolveName("/index.bop") == "servlet4");
}


void ServletExTest::testSplitPath()
{
	std::string path = "/";
	
	try
	{
		PathMapping::splitPath(path);
		fail("must throw");
	}
	catch(InvalidArgumentException&)
	{
	}

	path = "//";
	
	try
	{
		PathMapping::splitPath(path);
		fail("must throw");
	}
	catch(InvalidArgumentException&)
	{
	}

	path = "/c/d/";
	std::string context = PathMapping::splitPath(path);

	assert("/c" == context);
	assert("/d/" == path);

	path = "/c/d";
	context = PathMapping::splitPath(path);

	assert("/c" == context);
	assert("/d" == path);

	path = "/context/dir1/";
	context = PathMapping::splitPath(path);

	assert("/context" == context);
	assert("/dir1/" == path);

	path = "/context/dir1/dir2";
	context = PathMapping::splitPath(path);

	assert("/context" == context);
	assert("/dir1/dir2" == path);

	path = "/context/dir1/dir2/file.txt";
	context = PathMapping::splitPath(path);

	assert("/context" == context);
	assert("/dir1/dir2/file.txt" == path);

	path = "/context/dir1/../dir2/file.txt";
	context = PathMapping::splitPath(path);

	assert("/context" == context);
	assert("/dir2/file.txt" == path);
}


void ServletExTest::testHttpServletDispatcher()
{
	std::string name("ServletTest");
	HttpServletDispatcher servletDispatcher;
	ServletContextImpl sci(_rootDir + "webapps/ServletTest/", servletDispatcher);
	HttpServletDispatcher hsd;
	assert(sci.getName() == name);
	
	hsd.registerContext(name, &sci);
	assert(hsd.isRegistered(name));
	std::string name1(name);
	name1.insert(0, "/");
	assert(hsd.isRegistered(name1));
	name1 += '/';
	assert(hsd.isRegistered(name1));

	try
	{
		hsd.addMapping("unknown", _pm);
		fail("must throw");
	}
	catch(InvalidArgumentException&)
	{
	}

	hsd.addMapping(name, _pm);
	assert(hsd.resolve(name, "/foo/bar/index.html") == "servlet1");
	assert(hsd.resolve(name, "/foo/bar/index.bop") == "servlet1");
	assert(hsd.resolve(name, "/baz") == "servlet2");
	assert(hsd.resolve(name, "/baz/index.html") == "servlet2");
	assert(hsd.resolve(name, "/catalog") == "servlet3");
	assert(hsd.resolve(name, "/catalog/index.html") == "servlet0");
	assert(hsd.resolve(name, "/catalog/racecar.bop") == "servlet4");
	assert(hsd.resolve(name, "/index.bop") == "servlet4");
}


void ServletExTest::testFilterDispatcher()
{
	std::string name("ServletTest");
	HttpServletDispatcher servletDispatcher;
	ServletContextImpl sci(_rootDir + "webapps/ServletTest/", servletDispatcher);
	FilterDispatcher fd;
	assert(sci.getName() == name);
	
	fd.registerContext(name, &sci);
	assert(fd.isRegistered(name));
	std::string name1(name);
	name1.insert(0, "/");
	assert(fd.isRegistered(name1));
	name1 += '/';
	assert(fd.isRegistered(name1));

	try
	{
		fd.addMapping("unknown", _pm);
		fail("must throw");
	}
	catch(InvalidArgumentException&)
	{
	}

	fd.addMapping(name, _pm);
	assert(fd.resolve(name, "/foo/bar/index.html") == "servlet1");
	assert(fd.resolve(name, "/foo/bar/index.bop") == "servlet1");
	assert(fd.resolve(name, "/baz") == "servlet2");
	assert(fd.resolve(name, "/baz/index.html") == "servlet2");
	assert(fd.resolve(name, "/catalog") == "servlet3");
	assert(fd.resolve(name, "/catalog/index.html") == "servlet0");
	assert(fd.resolve(name, "/catalog/racecar.bop") == "servlet4");
	assert(fd.resolve(name, "/index.bop") == "servlet4");
}


void ServletExTest::testHttpServerConfig()
{
	std::vector<std::string> iface;
	iface.push_back("localhost:8080");
	HttpServerConfig hsc("test", iface);
	assert(hsc.getName() == "test");
	assert(*(hsc.interfaces().begin()) == "localhost:8080");
}


void ServletExTest::setUp()
{
	_pm.addMapping("/servlet0", "servlet0");
	_pm.addMapping("/servlet1", "servlet1");
	_pm.addMapping("/servlet2", "servlet2");
	_pm.addMapping("/servlet3", "servlet3");
	_pm.addMapping("/servlet4", "servlet4");
	_pm.addMapping("*.bop", "servlet4");
	_pm.addMapping("/", "servlet0");
	_pm.addMapping("/foo/bar/*", "servlet1");
	_pm.addMapping("/baz/*", "servlet2");
	_pm.addMapping("/catalog", "servlet3");
	_pm.addMapping("*.bop", "servlet4");
}


void ServletExTest::tearDown()
{
}


CppUnit::Test* ServletExTest::suite()
{
	CppUnit::TestSuite* pSuite = new CppUnit::TestSuite("ServletExTest");

	CppUnit_addTest(pSuite, ServletExTest, testPathMapping);
	CppUnit_addTest(pSuite, ServletExTest, testHttpServletDispatcher);
	CppUnit_addTest(pSuite, ServletExTest, testFilterDispatcher);
	CppUnit_addTest(pSuite, ServletExTest, testHttpServerConfig);
	
	return pSuite;
}
