//
// PathMapping.cpp
//
//
// Library: ServletEx
// Package: Servlet
// Module:  PathMapping
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Servlet/Ex/PathMapping.h"
#include "Poco/Path.h"
#include "Poco/Exception.h"


using Poco::Path;
using Poco::InvalidArgumentException;


namespace Poco {
namespace Servlet {
namespace Ex {


const char PathMapping::PATH_SEPARATOR = '/';


PathMapping::PathMapping()
{
}


PathMapping::~PathMapping()
{
}


void PathMapping::addMapping(const std::string& path, const std::string& name)
{
	_mapping[path] = name;
}


void PathMapping::removeName(const std::string& name)
{
	MappingMap::iterator it = _mapping.begin();	
	for(; it != _mapping.end();)
	{
		if(name == it->second) _mapping.erase(it++);
		else ++it;
	}
}


void PathMapping::removePath(const std::string& path)
{
	_mapping.erase(_mapping.find(path));
}


std::string PathMapping::resolvePath(const std::string& name) const
{
	MappingMap::const_iterator it = _mapping.begin();

	for(; it != _mapping.end(); ++it)
	{
		if (it->second == name) return it->first;
	}

	return "";
}


std::string PathMapping::resolveName(const std::string& path)
{
	std::string::size_type lastDot = path.find_last_of('.');
	std::string::size_type firstSlash = path.find_first_of(PATH_SEPARATOR);
	std::string::size_type lastSlash = path.find_last_of(PATH_SEPARATOR);

	MappingMap::iterator it = _mapping.find(path);
	//supplied path matches exactly
	if(it != _mapping.end())	return it->second;

	//try to match the '*' based path
	std::string slashStar("*");
	if(lastSlash==firstSlash) 
		slashStar.insert(static_cast<std::string::size_type>(0), static_cast<std::string::size_type>(1), PATH_SEPARATOR);
	std::string wcPath = path.substr(0, (lastSlash!=firstSlash)?lastSlash+1:path.size()) + slashStar;
	it = _mapping.begin();
	for(; it != _mapping.end(); ++it)
	{
		if(it->first == wcPath)
		{
			return it->second;
		}
	}

	//try to match the extension
	if((lastDot != path.npos) && 
		 (lastDot > lastSlash) || (lastSlash == path.npos))
	{
		std::string extension("*");
		extension += path.substr(lastDot, path.size()-1);
		it = _mapping.find(extension);
		if(it != _mapping.end()) return it->second;
	}

	//and finally, when everyting fails, 
	//see if there is default servlet
	it = _mapping.find("/");
	if(it != _mapping.end())	return it->second;

	//no matches found
	return "";
}


std::string PathMapping::getDefaultServlet(const std::string& path)
{
	MappingMap::iterator it = _mapping.find(path);
	if(it != _mapping.end())	return it->second;

	//no default servlet
	return "";
}


std::string PathMapping::splitPath(std::string& path)
{
	if((path.size() <= 3) || (PATH_SEPARATOR != path[0]))
		throw InvalidArgumentException("PathMapping::extractName::path=" + path);

	Path p(path, Path::PATH_UNIX);
	p.makeAbsolute();
	if(!p.depth()) return "";
	std::string context = p[0];
	context.insert(static_cast<std::string::size_type>(0), static_cast<std::string::size_type>(1), PATH_SEPARATOR);
	path = "";

	for(int i = 1; i <= p.depth(); ++i)
		path += PATH_SEPARATOR + p[i];

	p.assign(path, Path::PATH_UNIX);
	path = p.toString(Path::PATH_UNIX);

	if((path.size() >= 2) && (PATH_SEPARATOR == path[0]) && ('*' == path[1]))
		path.erase(0,1);

	return context;
}


} } } // namespace Poco::Servlet::Ex
