//
// HttpServlet.cpp
//
//
// Library: Servlet
// Package: Http
// Module:  HttpServlet
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Copyright (c) 2004 The Apache Software Foundation.
// http://www.apache.org/licenses/LICENSE-2.0
// 


#include "Poco/Servlet/HttpServlet.h"
#include "Poco/Servlet/ServletOutputStream.h"
#include "Poco/Servlet/NoBodyResponse.h"
#include "Poco/Servlet/HttpServletRequest.h"
#include "Poco/Servlet/HttpServletRequestWrapper.h"
#include "Poco/Servlet/HttpServletResponse.h"
#include "Poco/Servlet/HttpServletResponseWrapper.h"
#include "Poco/NullStream.h"
#include "Poco/Exception.h"
#include <sstream>


namespace Poco {
namespace Servlet {


///HttpServlet

std::vector<std::string> HttpServlet::SUPPORTED_METHODS;
const std::string HttpServlet::METHOD_DELETE     = "DELETE";
const std::string HttpServlet::METHOD_HEAD       = "HEAD";
const std::string HttpServlet::METHOD_GET        = "GET";
const std::string HttpServlet::METHOD_OPTIONS    = "OPTIONS";
const std::string HttpServlet::METHOD_POST       = "POST";
const std::string HttpServlet::METHOD_PUT        = "PUT";
const std::string HttpServlet::METHOD_TRACE      = "TRACE";
const std::string HttpServlet::HEADER_IFMODSINCE = "If-Modified-Since";
const std::string HttpServlet::HEADER_LASTMOD    = "Last-Modified";
const std::string HttpServlet::LSTRING_FILE      = "resource/servlet/http/LocalStrings";


HttpServlet::HttpServlet()
{
	SUPPORTED_METHODS.push_back("doOptions");
	SUPPORTED_METHODS.push_back("doTrace");
}


void HttpServlet::doGet(HttpServletRequest& req, HttpServletResponse& resp)
{
	checkConfig();
	std::string protocol = req.getProtocol();
	std::string msg = "Method GET not supported.";//lStrings.getString("http.method_get_not_supported");
	if (0 != protocol.find("1.1")) 
	{
		resp.sendError(HttpServletResponse::SC_METHOD_NOT_ALLOWED, msg);
	}
	else 
	{
		resp.sendError(HttpServletResponse::SC_BAD_REQUEST, msg);
	}
}


long HttpServlet::getLastModified(HttpServletRequest& req) 
{
	return -1;
}


void HttpServlet::doHead(HttpServletRequest& req, HttpServletResponse& resp)
{
	NoBodyResponse response(resp);
	doGet(req, response);
}


void HttpServlet::doPost(HttpServletRequest& req, HttpServletResponse& resp)
{
	std::string protocol = req.getProtocol();
	std::string msg = "Method POST Not Supported";//lStrings.getString("http.method_post_not_supported");
	if (0 != protocol.find("1.1")) 
	{
		resp.sendError(HttpServletResponse::SC_METHOD_NOT_ALLOWED, msg);
	} else 
	{
		resp.sendError(HttpServletResponse::SC_BAD_REQUEST, msg);
	}
}


void HttpServlet::doPut(HttpServletRequest& req, HttpServletResponse& resp)
{
	std::string protocol = req.getProtocol();
	std::string msg = "Method PUT not supported";//lStrings.getString("http.method_put_not_supported");
	if (0 != protocol.find("1.1")) 
	{
		resp.sendError(HttpServletResponse::SC_METHOD_NOT_ALLOWED, msg);
	} else 
	{
		resp.sendError(HttpServletResponse::SC_BAD_REQUEST, msg);
	}
}


void HttpServlet::doDelete(HttpServletRequest& req, HttpServletResponse& resp)
{
	std::string protocol = req.getProtocol();
	std::string msg = "http.method_delete_not_supported";//lStrings.getString("http.method_delete_not_supported");
	if (0 != protocol.find("1.1")) 
	{
		resp.sendError(HttpServletResponse::SC_METHOD_NOT_ALLOWED, msg);
	} else 
	{
		resp.sendError(HttpServletResponse::SC_BAD_REQUEST, msg);
	}
}


void HttpServlet::doOptions(HttpServletRequest& req, HttpServletResponse& resp)
{
	bool ALLOW_GET = false;
	bool ALLOW_HEAD = false;
	bool ALLOW_POST = false;
	bool ALLOW_PUT = false;
	bool ALLOW_DELETE = false;
	bool ALLOW_TRACE = true;
	bool ALLOW_OPTIONS = true;
	
	for (int i=0; i<SUPPORTED_METHODS.size(); i++) 
	{
			std::string m = SUPPORTED_METHODS[i];
	    
			if ("doGet" == m) 
			{
				ALLOW_GET = true;
				ALLOW_HEAD = true;
			}
			if ("doPost" == m)	ALLOW_POST = true;
			if ("doPut" == m)	ALLOW_PUT = true;
			if ("doDelete" == m) ALLOW_DELETE = true;
	}

	std::string allow = "";
	if (ALLOW_GET)
			if ("" == allow) allow=METHOD_GET;
	if (ALLOW_HEAD)
			if ("" == allow) allow=METHOD_HEAD;
			else allow += ", " + METHOD_HEAD;
	if (ALLOW_POST)
			if ("" == allow) allow=METHOD_POST;
			else allow += ", " + METHOD_POST;
	if (ALLOW_PUT)
			if ("" == allow) allow=METHOD_PUT;
			else allow += ", " + METHOD_PUT;
	if (ALLOW_DELETE)
			if ("" == allow) allow=METHOD_DELETE;
			else allow += ", " + METHOD_DELETE;
	if (ALLOW_TRACE)
			if ("" == allow) allow=METHOD_TRACE;
			else allow += ", " + METHOD_TRACE;
	if (ALLOW_OPTIONS)
			if ("" == allow) allow=METHOD_OPTIONS;
			else allow += ", " + METHOD_OPTIONS;
	
	resp.setHeader("Allow", allow);
	resp.flushBuffer();
}


void HttpServlet::doTrace(HttpServletRequest& req, HttpServletResponse& resp) 
{
	int responseLength;
	
	std::string CRLF = "\r\n";
	std::ostringstream ors;
	ors << "TRACE " << req.getRequestURI() << " " << req.getProtocol();
	
	std::vector<std::string> reqHeaderEnum = req.getHeaderNames();
	
	std::vector<std::string>::const_iterator it = reqHeaderEnum.begin();
	for(; it != reqHeaderEnum.end(); ++it)
	{
		std::string headerName = *it;
		ors << CRLF << headerName << ": " << req.getHeader(headerName); 
	}
	
	ors << CRLF;
	
	responseLength = (int) ors.str().length();
	
	resp.setContentType("message/http");
	resp.setContentLength(responseLength);
	ServletOutputStream& out = resp.getOutputStream();
	out.print(ors.str());	
	resp.flushBuffer();

	return;
}		


void HttpServlet::service(HttpServletRequest& req, HttpServletResponse& resp)
{
	checkConfig();
	std::string method = req.getMethod();

	if (METHOD_GET == method) 
	{
			long lastModified = getLastModified(req);
			if (-1 == lastModified) 
			{
				doGet(req, resp);
			} else 
			{
				long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
				if (ifModifiedSince < (lastModified / 1000 * 1000)) 
				{
					maybeSetLastModified(resp, lastModified);
					doGet(req, resp);
				} else 
				{
					resp.setStatus(HttpServletResponse::SC_NOT_MODIFIED);
				}
			}

	} else if (METHOD_HEAD == method) 
	{
		long lastModified = getLastModified(req);
		maybeSetLastModified(resp, lastModified);
		doHead(req, resp);

	} 
	else if (METHOD_POST == method)		doPost(req, resp);
	else if (METHOD_PUT == method)		doPut(req, resp);	
	else if (METHOD_DELETE == method)	doDelete(req, resp);
	else if (METHOD_OPTIONS == method)	doOptions(req,resp);
	else if (METHOD_TRACE == method)	doTrace(req,resp);
	else 
		resp.sendError(HttpServletResponse::SC_NOT_IMPLEMENTED, "Method not implemented");
}


void HttpServlet::maybeSetLastModified(HttpServletResponse& resp, long lastModified) 
{
	if (resp.containsHeader(HEADER_LASTMOD)) return;
	if (lastModified >= 0) resp.setDateHeader(HEADER_LASTMOD, lastModified);
}


void HttpServlet::service(ServletRequest& req, ServletResponse& res)
{
	HttpServletRequest* pRequest = dynamic_cast<HttpServletRequest *>(&req);
	poco_check_ptr(pRequest);

	HttpServletResponse* pResponse = dynamic_cast<HttpServletResponse *>(&res);
	poco_check_ptr(pResponse);

	service(*pRequest, *pResponse);
}


} } // namespace Poco::Servlet
