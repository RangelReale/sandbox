//
// WebServer.cpp
//
// Library: Container
// Package: ContainerCore
// Module:  WebServer
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Servlet/Container/WebServer.h"
#include "Poco/Servlet/Container/ContainedFactory.h"
#include "Poco/Servlet/Ex/HttpServerConfig.h"
#include "Poco/NumberParser.h"
#include "Poco/NumberFormatter.h"
#include "Poco/Mutex.h"
#include "Poco/Exception.h"


using Poco::Util::XMLConfiguration;
using Poco::Servlet::Ex::HttpServer;
using Poco::Servlet::Ex::HttpServletDispatcher;
using Poco::Servlet::Ex::HttpServerConfig;


namespace Poco {
namespace Servlet {
namespace Container {


FastMutex WebServer::_mutex;


WebServer::WebServer(const std::string& base, HttpServletDispatcher& dispatcher):
Contained(base), _dispatcher(dispatcher), _pServer(0)
{
	init();
}


WebServer::~WebServer()
{
	while(_classLoader.begin() != _classLoader.end())
		_classLoader.unloadLibrary(_classLoader.begin()->first);
}


void WebServer::init()
{
	setInitParameters();
	initLogging();
	initServers();
}


void WebServer::initServers()
{
	std::ostringstream ss("");
	std::map<int, std::string> loadServers;
	std::string serverClassName("");
	std::string serverLibName("");
	int cnt = 0;
	do
	{
		ss.str("");
		ss << "server[" << cnt << "].server-name";
		serverClassName = _pConf->getString(ss.str(), "");

		if("" == serverClassName) break;//no more servers

		ss.str("");
		ss << "server[" << cnt << "].server-lib";
		serverLibName = _pConf->getString(ss.str(), "");
		
		ss.str("");
		ss << "Found server class " << serverClassName
			 << " residing in shared library " << serverLibName;
		if(_pLogger) _pLogger->information(ss.str());

		int cntpar = 0;
		std::string name;
		std::string value;
		do
		{
			ss.str("");
			ss << "server[" << cnt << "].param-name[" << cntpar << "]";
			name = _pConf->getString(ss.str(), "");
			if("" == name) break;
			
			ss.str("");
			ss << "server[" << cnt << "].param-value[" << cntpar << "]";
			value = _pConf->getString(ss.str(), "");
			
			_initParamMap.insert(make_pair(name, value));

			if(_pLogger)
			{
				ss.str("");
				ss << "Init parameter: " << name << '=' << value;
				_pLogger->information(ss.str());
			}

			++cntpar;
			name = value = "";
		}while (true);

		cntpar = 0;
		cnt = 0;
		do
		{
			ss.str("");
			ss << "server[" << cnt << "].alias-mapping.alias[" << cntpar << "]";
			name = _pConf->getString(ss.str(), "");
			if("" == name) break;
			ss.str("");
			ss << "server[" << cnt << "].alias-mapping.directory[" << cntpar << "]";
			value = _pConf->getString(ss.str(), "");
			if("" == value) break;

			if(_pLogger)
			{
				ss.str("");
				ss << "Alias: " << name << '=' << value;
				_pLogger->information(ss.str());
			}

			_aliases.insert(std::make_pair(name, value));
			++cntpar;
		}while (true);

		ss.str("");
		ss << "server[" << cnt << "].load-on-startup";
		// negative or absent load-on-startup value means server should not be loaded
		if(NumberParser::parse(_pConf->getString(ss.str(), "-1")) >= 0)
		{
			if (loadSharedLib(serverLibName))
			{
				create(serverClassName, serverClassName);
			}
		}

		++cnt;
	}while(true);
}


void WebServer::create(const std::string& className, const std::string& serverName)
{
	std::ostringstream ss("");
	ContainedFactory<HttpServer> factory(_classLoader);
	FastMutex::ScopedLock lock(_mutex);

	try
	{
		_pServer = factory.createInstance(className); 
		if(_pServer)
		{
			std::string address = getInitParameter("address0", "");
			std::vector<std::string> addresses;

			if("" != address) 
			{
				addresses.push_back(address);
				int i = 0;
				while(true)
				{
					std::stringstream idx;
					idx << "address" << ++i;
					address = getInitParameter(idx.str(), "");
					if ("" == address) break;
					addresses.push_back(address);
				}
			}

			HttpServerConfig hsc(serverName, addresses, &_aliases, getInitParameter("global.dir", ""));

			_pServer->init(hsc, _dispatcher, _pLogger);

			ss << "Loaded server " << className;
			if(_pLogger) _pLogger->information(ss.str());
		}
	}
	catch(Exception& ex)
	{
		ss << "Server [" << className << "] failed to load";
		if(_pLogger) _pLogger->error(ss.str());
		if(_pLogger) _pLogger->error(ex.displayText());
		throw RuntimeException(ss.str());
	}
}


void WebServer::run() 
{
	if(_pServer)
	{
		if(_pLogger) _pLogger->information("Web server starting ...");
		_pServer->start();
	}
}


void WebServer::stop() 
{
	if(_pServer)
	{
		if(_pLogger) _pLogger->information("Web server stopping ...");
		_pServer->stop();
		if(_pLogger) _pLogger->information("Web server stopped.");
	}
}


void WebServer::setInitParameters()
{
	int cnt = 0;
	_displayName = _pConf->getString("display-name", "");
  
	do
	{
		std::stringstream ss("");
		std::string name("");
		std::string value("");

		ss << "context-param[" << cnt << "].param-name";
		name = _pConf->getString(ss.str(), "");
		ss.str("");
		ss << "context-param[" << cnt++ << "].param-value";
		value = _pConf->getString(ss.str(), "");
		
		if("" == name) break;

		setInitParameter(name, value);
	}while(true);
}


void WebServer::setInitParameter(const std::string& name, const std::string& value) 
{ 
	std::stringstream ss("");
	_initParamMap.insert(make_pair(name, value));
	ss << "Parameter set: [" << name << "]=[" << value << "]";
	
	if(_pLogger) _pLogger->information(ss.str());
}


std::string WebServer::getInitParameter(const std::string& name) const
{ 
	return getInitParameter(name, "") ;
}


std::string WebServer::getInitParameter(const std::string& name, const std::string& defValue) const
{ 
	ServerInitParamMap::const_iterator it = _initParamMap.find(name);
	if(it != _initParamMap.end()) return it->second;
	else return defValue;
}


bool WebServer::loadSharedLib(const std::string& fileName)
	/// Loads the specified shared lib.
{
	std::string dllFile = getSharedLibPath(fileName).toString();

	if(_pLogger)
	{
		std::ostringstream os;
		os << "Loading " << Poco::trim(dllFile);
		_pLogger->information(os.str());
	}

	if(!_classLoader.isLibraryLoaded(dllFile))
	{
			_classLoader.loadLibrary(dllFile);
	}

	return _classLoader.isLibraryLoaded(dllFile);
}


const std::vector<std::string>* WebServer::interfaces()
{
	if(_pServer) return &_pServer->interfaces();
	return 0;
}


} } } // namespace Poco::Servlet::Container'
