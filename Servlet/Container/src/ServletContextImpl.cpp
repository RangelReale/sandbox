//
// ServletContextImpl.cpp
//
// Library: Container
// Package: ContainerCore
// Module:  ServletContextImpl
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Servlet/Container/ServletContextImpl.h"
#include "Poco/Servlet/Container/WebApplication.h"
#include "Poco/Servlet/Ex/PathMapping.h"
#include "Poco/Servlet/Ex/HttpServletDispatcher.h"
#include "Poco/Servlet/Ex/HttpRequestDispatcher.h"
#include "Poco/Logger.h"
#include "Poco/PatternFormatter.h"
#include "Poco/FormattingChannel.h"
#include "Poco/SplitterChannel.h"
#include "Poco/ConsoleChannel.h"
#include "Poco/FileChannel.h"
#include "Poco/Message.h"
#include "Poco/File.h"
#include "Poco/Path.h"
#include "Poco/Exception.h"


using Poco::Servlet::Ex::PathMapping;
using Poco::Servlet::Ex::HttpServletDispatcher;
using Poco::Servlet::Ex::HttpRequestDispatcher;


namespace Poco {
namespace Servlet {
namespace Container {


ServletContextImpl::ServletContextImpl(const std::string& rootDir,
	HttpServletDispatcher& dispatcher, 
	Logger* pLogger):
	_pLogger(pLogger), 
	_rootDir(rootDir), 
	_name(Path(_rootDir)[Path(_rootDir).depth()-1]),
	_servletDispatcher(dispatcher)
{
}


ServletContextImpl::~ServletContextImpl()
{
}


const Object* ServletContextImpl::getAttribute(const std::string& name) const
{ 
	ObjectMap::const_iterator it = _attributes.find(name);
	if(it != _attributes.end()) return it->second;
	else						return 0; 
} 


std::vector<std::string> ServletContextImpl::getAttributeNames() const 
{ 
	std::vector<std::string> names;
	ObjectMap::const_iterator it = _attributes.begin();
	for(; it != _attributes.end(); ++it)
	{
		names.push_back((*it).first);
	}

	return names;
}


const ServletContext* ServletContextImpl::getContext(const std::string& uripath) const
{ 
	return 0; 
}


void ServletContextImpl::setInitParameters(const Poco::Util::LayeredConfiguration& conf)
{
	_displayName = conf.getString("display-name", "");
	setInitParameter("display-name", conf.getString("display-name", ""));
	extractParameters(conf, "context-param", "param-name", "param-value");
	assignMappings(conf);
}


void ServletContextImpl::assignServletMapping(const std::string& path, const std::string& servlet)
{
	_servletMapping.addMapping(path, servlet);
}


void ServletContextImpl::assignMappings(const Poco::Util::LayeredConfiguration& conf)
{
	int cnt = 0;
	do
	{
		std::ostringstream ss;
		std::string servlet;
		std::string path;

		ss << "servlet-mapping[" << cnt << "].servlet-name";
		servlet = conf.getString(ss.str(), "");
		if("" == servlet) break;

		ss.str("");
		ss << "servlet-mapping[" << cnt << "].url-pattern";
		path = conf.getString(ss.str(), "");

		assignServletMapping(path, servlet);
		++cnt;
	}while(true);

	cnt = 0;
	do
	{
		std::ostringstream ss;
		std::string filter;
		std::string path;

		ss << "filter-mapping[" << cnt << "].filter-name";
		filter = conf.getString(ss.str(), "");
		if("" == filter) break;

		ss.str("");
		ss << "filter-mapping[" << cnt << "].url-pattern";
		path = conf.getString(ss.str(), "");

		if("" != path)
		{
			_filterURLMapping.addMapping(path, filter);
		}
		else
		{
			ss.str("");
			ss << "filter-mapping[" << cnt << "].servlet-class";
			path = conf.getString(ss.str(), "");
			addFilterServletMapping(filter, path);
		}

		++cnt;
	}while(true);
}


void ServletContextImpl::addFilterServletMapping(const std::string& filter, const std::string& path)
{
	_filterServletMapping.insert(std::make_pair(filter, path));
}


void ServletContextImpl::extractParameters(const Poco::Util::LayeredConfiguration& conf,
	const std::string& parent,
	const std::string& child1,
	const std::string& child2)
{
	int cnt = 0;

	do
	{
		std::stringstream ss("");
		std::string name("");
		std::string value("");

		ss << parent << "[" << cnt << "]." << child1;
		name = conf.getString(ss.str(), "");
		ss.str("");
		ss << parent << "[" << cnt++ << "]." << child2;
		value = conf.getString(ss.str(), "");
		
		if("" == name) break;

		setInitParameter(name, value);
	}while(true);
}


void ServletContextImpl::setInitParameter(const std::string& name, const std::string& value) 
{ 
	std::stringstream ss("");
	_initParams.insert(make_pair(name, value));
	ss << "Parameter set: [" << name << "]=[" << value << "]";
	log(ss.str());
}


std::string ServletContextImpl::getInitParameter(const std::string& name) const
{ 
	return getInitParameter(name, "") ;
}


std::string ServletContextImpl::getInitParameter(const std::string& name, const std::string& defValue) const
{ 
	ContextInitParamMap::const_iterator it = _initParams.find(name);
	if(it != _initParams.end())
		return it->second;
	else
		return defValue;
}


std::vector<std::string> ServletContextImpl::getInitParameterNames() const
{ 
	std::vector<std::string> names;
	ContextInitParamMap::const_iterator it = _initParams.begin();
	for(; it != _initParams.end(); ++it)
	{
   names.push_back((*it).first);
	}

	return names;
}


//const RequestDispatcher* ServletContextImpl::getRequestDispatcher(const std::string& path) const 
//{ 
//	return new HttpRequestDispatcher(_servletDispatcher, path);
//}


void ServletContextImpl::removeAttribute(const std::string& name)  
{
	_attributes.erase(name);
}


void ServletContextImpl::setAttribute(std::string name, const Object* pAttribute)
{
	if(!pAttribute) removeAttribute(name);
	else			_attributes[name] = pAttribute;
}


//const RequestDispatcher* ServletContextImpl::getNamedDispatcher(const std::string& name) const
//{ 
//	return getRequestDispatcher(_servletMapping.resolvePath(name));
//}


std::string ServletContextImpl::getRealPath(const std::string& path) const 
{ 
	Path p(_rootDir + '/' + path);
	return p.toString();
}


const PathMapping& ServletContextImpl::getServletPathMapping() const
{
	return _servletMapping;
}


const PathMapping& ServletContextImpl::getFilterPathMapping() const
{
	return _filterURLMapping;
}


const ServletContextImpl::FilterServletMapping& ServletContextImpl::getFilterServletMapping() const
{
	return _filterServletMapping;
}


std::string ServletContextImpl::getServerInfo()  
{ 
	std::ostringstream os;
	os << SERVLET_SERVER_NAME << " /" << POCO_SERVLET_VERSION_MAJOR << '.' << POCO_SERVLET_VERSION_MINOR;
	return os.str();
}


std::string ServletContextImpl::getMimeType(const std::string& file) const
{
	if (_pMimeMap)
	{
		MimeMap::const_iterator it = _pMimeMap->find(file.substr(file.find_last_of('.')+1));

		if(_pMimeMap->end() != it) return it->second;
	}

	return "";
}


} } } // namespace Poco::Servlet::Container'
