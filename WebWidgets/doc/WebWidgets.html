<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>POCO WebWidgets Documentation</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="author" content="Applied Informatics"/>
<meta name="publisher" content="Applied Informatics"/>
<meta name="copyright" content="Copyright (c) 2007, Applied Informatics"/>
<meta name="language" content="en"/>
<meta name="date" content="2007-06-27"/>
<meta name="generator" content="PocoDoc"/>
<link rel="stylesheet" href="css/styles.css" type="text/css"/>
</head>
<body bgcolor="#ffffff" leftmargin="0" topmargin="0">
<div class="header">
<h1 class="category">WebWidgets</h1>
<h1 class="title">POCO WebWidgets Documentation</h1>
</div>
<div class="body">
<div class="description">
<p></p><h2>Introduction</h2><p>
</p>
<p>POCO WebWidgets is a library combining HTML generation with Javascript usage. WebPages can be easily created either in C++ code or via XML configuration loading. Each GUI element offers events as known from the HTML standard and supports registration of client-side callbacks (i.e. Javascript function calls) and server-side callbacks (i.e. for each event a HTTPRequest is sent to the server). This documentation will present in detail the available GUI elements and their usage. </p>
<p></p>
<p></p><h2>GUI Elements</h2><p>
</p>
<p></p><h3>Widget</h3><p>
</p>
<p>The root class for all GUI elements is <i>Widget</i>. A Widget supports via the methods <i> preVisit</i> and <i> visit </i> a two-step visitor pattern. A Widget can be searched for other Widgets via the <i>find</i> method. All Widgets offer events and are creatable by loading and parsing an XML file. </p>
<p></p><h4>Common XML Attributes</h4><p>
</p>
<p>Each Widget can be loaded via an XML configuration. A simple example for a text label would be:  </p>
<pre>&lt;label&gt;Test Label&lt;/label&gt;
</pre>
<p> </p>
<p>Furthermore, all widgets share a common set of attributes: </p>
<ul>
<li>id: a unique identifier. Each Widget should have one. When the HTML generator encounters a Widget without an <tt>id</tt>, it auto-assigns one.  </li>
<li>class: CSS information of the class. Each different Widget type comes with a default value which can be overwritten. </li>
<li>lang: language information (see HTML docu for more info) </li>
<li>style: style information (see HTML docu for more info) </li>
<li>title: (see HTML docu for more info) </li>
</ul>
<p>Thus, a label with an <tt>id</tt> and a <tt>class</tt> will look like this:   </p>
<pre>&lt;label id=&quot;lbl1&quot; class=&quot;label&quot;&gt;Test Label&lt;/label&gt;
</pre>
<p> </p>
<p></p><h4>Finding Children</h4><p>
</p>
<p>A GUI is a tree of GUI elements. Suppose you have created a GUI which contains a child named <tt>c1</tt> and you want to retrieve it: </p>
<pre>using Poco::WebWidgets::Widget;
using Poco::WebWidgets::XMLUtil;

std::ifstream in(&quot;mygui.xml&quot;);
if (!in)
    throw Poco::FileNotFoundException(&quot;mygui.xml&quot;);
Poco::AutoPtr&lt;Widget&gt; ptrRoot =  XMLUtil::loadWidget(in);
Poco::AutoPtr&lt;Widget&gt; ptrChild = Widget::find(ptrRoot, &quot;c1&quot;);
poco_assert (ptrChild);
 [...]; // continue using ptrChild, like registering delegates,...
</pre>
<p> </p>
<p>Note that finding a child is an expensive operation which in the worst case requires full tree traversal. </p>
<p></p>
<p></p><h4>Events</h4><p>
Widgets come with their own event flavor called <tt>JavaScriptEvent</tt>. A JavaScriptEvent can be seen as a sort of extended <tt>Poco::BasicEvent</tt>. Thus, all the methods known from BasicEvent work: </p>
<p></p>
<pre>using Poco::WebWidgets::Widget;
Poco::AutoPtr&lt;Widget&gt; ptrWidget = [...];
ptrWidget-&gt;ESingleClick += delegate(this, &amp;MyClass::onSingleClickMethod);
[...]
ptrWidget-&gt;ESingleClick -= delegate(this, &amp;MyClass::onSingleClickMethod);
</pre>
<p> </p>
<p>JavaScriptEvents were extended in two different ways: </p>
<ul>
<li>first, we can now detect if any (server) delegate is registered at it. The HTML generator uses that information to decide if it needs to generate a callback to the server. A callback is only generated for an event if at least one server delegate is registered. This optimization is needed to keep GUI response times acceptable. </li>
<li>second, we can now add <i> JSDelegates </i> to the event. A JSDelegate is basically a JavaScript function name plus the JavaScript file we need to load on the client-side. If more than one JSDelegate is registered, the HTML generator will generate a wrapper method that calls the JSDelegates sequentially. </li>
</ul>
<p>An example for JSDelegate would be: </p>
<pre>using Poco::WebWidgets::JSDelegate;
using Poco::WebWidgets::jsDelegate;
using Poco::WebWidgets::Widget;

Poco::AutoPtr&lt;Widget&gt; ptrWidget = [...];
ptrWidget-&gt;ESingleClick += JSDelegate(&quot;onSingleClick&quot;, &quot;appinf.js&quot;);
ptrWidget-&gt;ESingleClick += jsDelegate(&quot;onSingleClick2&quot;, &quot;additional.js&quot;);
</pre>
<p> </p>
<p>The HTML generator will generate the following code for that. Note that we assume that the widget has the id <tt>i2</tt>: </p>
<pre>&lt;script src=&quot;additional.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;appinf.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    function multiEventHandleronclicki2(ev) {
        if (!ev) {
            ev = window.event;
        }
        onSingleClick(ev);
        onSingleClick2(ev);
    }
&lt;/script&gt;
</pre>
<p> </p>
<p>Method signatures of JSDelegates must take as input a JavaScript event object. </p>
<p>The Widget class offers for each different event type a JavaScriptEvent: </p>
<pre>JavaScriptEvent&lt;MouseEventArgs&gt; ESingleClick;
JavaScriptEvent&lt;MouseEventArgs&gt; EDoubleClick;
JavaScriptEvent&lt;MouseEventArgs&gt; EMouseDown;
JavaScriptEvent&lt;MouseEventArgs&gt; EMouseUp;
JavaScriptEvent&lt;MouseMovementArgs&gt; EMouseOver;
JavaScriptEvent&lt;MouseMovementArgs&gt; EMouseOut;
JavaScriptEvent&lt;MouseMovementArgs&gt; EMouseMove;
JavaScriptEvent&lt;KeyboardFocusArgs&gt; EFocusEnter;
JavaScriptEvent&lt;KeyboardFocusArgs&gt; EFocusLost;
JavaScriptEvent&lt;KeyEventArgs&gt; EKeyUp;
JavaScriptEvent&lt;KeyEventArgs&gt; EKeyDown;
JavaScriptEvent&lt;KeyEventArgs&gt; EKeyPressed;
</pre>
<p> </p>
<p>Note that not all events are meaningful for all widgets! Some will never fire, some might behave differently with different browsers. There is still a lot of work to do in that area! </p>
<p></p><h4>JSDelegates in XML</h4><p>
</p>
<p>JSDelegates can be configured via the XML file. Simply add to the Widget node a child named <i>events</i> and create for each different event type a child element with the name of the event. Then add your jsDelegates via the keyword <i>delegate</i>. The mapping of <i>JavaScriptEvent</i> to XML element name is as given: </p>
<ul>
<li>ESingleClick: onclick </li>
<li>EDoubleClick: ondblclick </li>
<li>EMouseDown: onmousedown </li>
<li>EMouseUp: onmouseup </li>
<li>EMouseOver: onmouseover </li>
<li>EMouseOut: onmouseout </li>
<li>EMouseMove: onmousemove </li>
<li>EFocusEnter: onfocus </li>
<li>EFocusLost: onblur </li>
<li>EKeyUp: onkeyup </li>
<li>EKeyDown: onkeydown </li>
<li>EKeyPressed: onkeypressed </li>
</ul>
<p>Assume that we have a label where we want to find out whenever someone is moving the mouse over it: </p>
<pre>&lt;label&gt;
    Test Label
    &lt;events&gt;
        &lt;onmouseover&gt;
            &lt;delegate function=&quot;printMessage&quot; file=&quot;appinf.js&quot;/&gt; 
        &lt;/onmouseover&gt;
    &lt;/events&gt;
&lt;/label&gt;
</pre>
<p> </p>
<p></p><h3>InputField</h3><p>
An InputField extends Widget and is the abstract root class for all form members that can send data back to the server. </p>
<p></p><h4>Events</h4><p>
In addition to the events inherited from Widget, an InputField has the following JavaScriptEvents: </p>
<pre>JavaScriptEvent&lt;InputField*&gt; EChange;
JavaScriptEvent&lt;InputField*&gt; ESelect; 
</pre>
<p> </p>
<p>which maps to the following XML keywords: </p>
<ul>
<li>EChange: onchange </li>
<li>ESelect: onselect </li>
</ul>
<p>Additionally, an InputField comes with a BasicEvent which works without JavaScript being enabled: </p>
<ul>
<li>Poco::BasicEvent&lt;const std::string&gt; NewText: thrown, whenever a new text is sent back from the client </li>
</ul>
<p>This event will be fired whenever the value of the input field is updated at the server. This typically happens when the client clicks on a submit <tt>Button</tt>. </p>
<p></p>
<p></p><h3>RootPanel</h3><p>
A RootPanel is the root widget for each GUI. Each Web page MUST have a RootPanel as its root element. It allows to set header specific information (by adding a HTML widget to the header element) and it takes <tt>n</tt> Widgets as children. The HTML code generated by a RootPanel is always a complete web page. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>RootPanel(const std::string&amp; name, 
          const std::vector&lt;Poco::AutoPtr&lt;Widget&gt; &gt;&amp; children = std::vector&lt;Poco::AutoPtr&lt;Widget&gt; &gt;());
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>rootPanel
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>name: mandatory </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;rootPanel name=&quot;Test Document&quot;&gt;
&lt;header&gt;
    &lt;html&gt;
        &lt;![CDATA[
        [...]
        ]]&gt;
    &lt;/html&gt;
&lt;/header&gt;
&lt;children&gt;
    &lt;!-- set of widgets --&gt;
&lt;/children&gt;
</pre>
<p>&lt;/rootPanel&gt;  </p>
<p></p><h3>Button</h3><p>
</p>
<p>A standard click button, can be of type <i>reset</i> or <i>submit</i>. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>Button(const std::string&amp; text, 
       Type t = TYPE_SUBMIT); // TYPE_RESET
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>button
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>text: mandatory </li>
<li>type: optional, values = [submit|reset], default = submit </li>
<li>class: optional, when not set <i> button </i> is used. </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;button text=&quot;Click&quot; type=&quot;submit&quot;/&gt;
</pre>
<p>     </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;input class=&quot;button&quot; id=&quot;i8&quot; type=&quot;submit&quot; value=&quot;Click&quot;/&gt;
</pre>
<p> </p> <input class="button" id="i8" type="submit" value="Click"/> <p> </p>
<p></p><h3>CheckBox</h3><p>
A CheckBox is an InputField, checkBoxes can be grouped together by assigning them identical names. Multiple selection inside a group is possible. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>CheckBox(const std::string&amp; name, const std::string&amp; text, bool checked = false);
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>checkBox
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>name: mandatory, must not be empty, must be unique inside the used form </li>
<li>checked: optional, values = [true|false], default = false </li>
<li>class: optional, when not set <i> checkbox </i> is used </li>
</ul>
<p></p>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;checkBox id=&quot;c1&quot; name=&quot;check&quot; checked=&quot;true&quot;&gt;Check This&lt;/checkBox&gt;
&lt;checkBox id=&quot;c2&quot; name=&quot;check&quot;&gt;Check That&lt;/checkBox&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;input checked=&quot;checked&quot; class=&quot;checkbox&quot; id=&quot;c1&quot; name=&quot;check&quot; type=&quot;checkbox&quot; value=&quot;Check This&quot;/&gt;Check This&lt;br&gt;
&lt;input class=&quot;checkbox&quot; id=&quot;c2&quot; name=&quot;check&quot; type=&quot;checkbox&quot; value=&quot;Check That&quot;/&gt;Check That
</pre>
<p> </p> <input checked="checked" class="checkbox" id="c1" name="check" type="checkbox" value="Check This"/>Check This<br> <input class="checkbox" id="c2" name="check" type="checkbox" value="Check That"/>Check That <p> </p>
<p></p>
<p></p><h3>ComboBox</h3><p>
A ComboBox offers a drop-down menu that can only contain labels. When created from an XML file, all children not equal to <i>label</i> are simply ignored. A ComboBox only allows to select one single element. If multi-selection is required, consider using a <tt>ListView</tt>. Note that a selection of -1 means nothing is selected, indices start with 0. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>ComboBox(const std::string&amp; uniqueName, 
         const std::vector&lt;Poco::AutoPtr&lt;Label&gt; &gt;&amp; children = std::vector&lt;Poco::AutoPtr&lt;Label&gt; &gt;(), 
         int selected = -1);
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>comboBox
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>name: mandatory </li>
<li>selected: optional, which element should be pre-selected, type = integer, default = -1 </li>
<li>class: optional, when not set <i> combobox </i> is used </li>
</ul>
<p></p>
<p></p><h4>XML Example</h4><p>
The following example will pre-select the 3rd label (indizes start with 0!). </p>
<pre>&lt;comboBox name=&quot;combo&quot; select=&quot;2&quot; id=&quot;c1&quot;&gt;
    &lt;label&gt;1st&lt;/label&gt;
    &lt;label&gt;2nd&lt;/label&gt;
    &lt;label&gt;3rd&lt;/label&gt;
    &lt;label&gt;4th&lt;/label&gt;
&lt;/comboBox&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;select class=&quot;combobox&quot; id=&quot;c1&quot; name=&quot;combo&quot; size=&quot;1&quot;&gt;
    &lt;option&gt;1st&lt;/option&gt;
    &lt;option&gt;2nd&lt;/option&gt;
    &lt;option selected=&quot;selected&quot;&gt;3rd&lt;/option&gt;
    &lt;option&gt;4th&lt;/option&gt;
&lt;/select&gt;
</pre>
<p> </p> <select class="combobox" id="c1" name="combo" size="1"> <option>1st</option> <option>2nd</option> <option selected="selected">3rd</option> <option>4th</option> </select> <p> </p>
<p></p><h3>FlowPanel</h3><p>
A FlowPanel stores widgets next to each other as long as the page is wide enough. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>FlowPanel(const std::vector&lt;Poco::AutoPtr&lt;Widget&gt; &gt;&amp; children = std::vector&lt;Poco::AutoPtr&lt;Widget&gt; &gt;());
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>flow
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
No attributes. </p>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;flow&gt;
    &lt;label&gt;Test Label&lt;/label&gt;
    &lt;label&gt;2nd Label&lt;/label&gt;
    &lt;label&gt;3rd Label&lt;/label&gt;
&lt;/flow&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;a&gt;Test Label&lt;/a&gt;&lt;a&gt;2nd Label&lt;/a&gt;&lt;a&gt;3rd Label&lt;/a&gt;
</pre>
<p> </p> <a>Test Label</a><a>2nd Label</a><a>3rd Label</a> <p> </p>
<p></p>
<p></p><h3>Form</h3><p>
A HTML form object contains multiple other widgets, mostly InputField objects.  A Form contains two urls: one allows to specify the action that should be executed e.g. the url of a CGI script, and the 2nd optional URL is a redirect to a page that should be shown after processing has finished. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>Form(const Poco::URI&amp; action, 
     const Poco::URI&amp; redirect, 
     Method m = M_GET|, //M_POST
     const std::vector&lt;Poco::AutoPtr&lt;Widget&gt; &gt;&amp; children = std::vector&lt;Poco::AutoPtr&lt;Widget&gt; &gt;());
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>form
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>action: mandatory, URL </li>
<li>redirect: optional, URL, if empty, action is used </li>
<li>method: optional, value = [get|post], default = get </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;form id=&quot;f1&quot; action=&quot;/test.xml&quot; method=&quot;post&quot;&gt;
    [...]
&lt;/form&gt;
</pre>
<p> </p>
<p></p>
<p></p><h3>HidablePanel</h3><p>
A HidablePanel decorates a single widget with a text and a minimize button. If you want to add more than one Widget, use a <tt>StackPanel</tt>, a <tt>FlowPanel</tt> or a <tt>Table</tt> to organize these widgets, and add that single Widget. Minimizing/maximizing requires JavaScript to be enabled. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>HidablePanel(Poco::AutoPtr&lt;Widget&gt; ptr, 
             const Poco::URI&amp; onImage, 
             const Poco::URI&amp; offImage, 
             const std::string&amp; text, 
             bool inlineMode = false);
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>hidablePanel 
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>on: mandatory, the URL of the image to be shown when the Widget is maximized </li>
<li>off: mandatory, the URL of the image to be shown when the Widget is minimized </li>
<li>text: mandatory, the Text to write next to the image </li>
<li>inline: optional, value=[true|false], default = false, if true we allow text to flow around the maximized element, otherwise whole page width is used </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;hidablePanel id=&quot;h1&quot; on=&quot;images/on.gif&quot; off=&quot;images/off.gif&quot; text=&quot;Extended Settings&quot;&gt;
    &lt;flow&gt;
        &lt;label&gt;First Name&lt;/label&gt;
        &lt;textField id=&quot;t1&quot; size=&quot;20&quot; maxLength=&quot;40&quot; name=&quot;first&quot;/&gt;
    &lt;/flow&gt;
&lt;/hidablePanel&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>function onClickh1() {
    var child = $(&quot;hpt1&quot;);
    var imgBut = $(&quot;hpi1&quot;);
    if (child.style.display == &quot;none&quot;) {
        child.style.display = &quot;block&quot;;
        imgBut.src = &quot;images/on.gif&quot;;
    } else {
        child.style.display = &quot;none&quot;;
        imgBut.src = &quot;images/off.gif&quot;;
    }
}

&lt;input class=&quot;imagebutton&quot; id=&quot;hpi1&quot; onclick=&quot;onClickh1()&quot; src=&quot;images/on.gif&quot; type=&quot;image&quot;/&gt;Extended Settings&lt;br/&gt;
&lt;input class=&quot;textfield&quot; id=&quot;hpt1&quot; maxlength=&quot;40&quot; name=&quot;first&quot; size=&quot;20&quot; type=&quot;text&quot;/&gt;
</pre>
<p> </p>
<p></p>  <script type="text/javascript"> function $(id) { return document.getElementById(id); } function onClickh1() { var child = $("hpt1"); var imgBut = $("hpi1"); if (child.style.display == "none") { child.style.display = "block"; imgBut.src = "images/on.gif"; } else { child.style.display = "none"; imgBut.src = "images/off.gif"; } } </script> <input class="imagebutton" id="hpi1" onclick="onClickh1()" src="images/on.gif" type="image"/>Extended Settings<br/> <input class="textfield" id="hpt1" maxlength="40" name="first" size="20" type="text"/> <p> </p>
<p></p><h3>HTML</h3><p>
Use this class to inject raw HTML into a GUI. When defined in an XML file, wrap <tt>CDATA</tt> around the HTML code. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>HTML(const std::string&amp; txt);
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>html
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
No attributes. </p>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;html&gt;
&lt;![CDATA[
    &lt;meta name=&quot;Date&quot; content=&quot;2005-11-15T23:31:20+01:00&quot;&gt;
    &lt;meta name=&quot;Identifier&quot;  content=&quot;http://appinf.com/html/test.htm&quot;&gt;
    &lt;meta name=&quot;Language&quot; content=&quot;de&quot;&gt;
]]&gt;
&lt;/html&gt;
</pre>
<p> </p>
<p></p><h3>HyperLink</h3><p>
The HyperLink object simplifies link insertion. It can contain either a label or an image as child. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>HyperLink(const Poco::URI&amp; uri, Poco::AutoPtr&lt;Widget&gt; ptrWidget=Poco::AutoPtr&lt;Widget&gt;());
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>hyperLink
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>ref: mandatory, the target URL of the link. </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;hyperLink ref=&quot;http://pocoproject.org&quot;&gt;
    &lt;image&gt;...&lt;/image&gt;
&lt;/hyperLink&gt;
&lt;hyperLink ref=&quot;http://pocoproject.org&quot;&gt;
    &lt;label&gt;The POCO Project&lt;/label&gt;
&lt;/hyperLink&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;a href=&quot;http://pocoproject.org&quot; id=&quot;l1&quot;&gt;The POCO Project&lt;/a&gt;
</pre>
<p> </p> <a href="http://pocoproject.org" id="l1">The POCO Project</a> <p> </p>
<p></p><h3>Image</h3><p>
Used to embed an image into a web page.  </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>Image(const Poco::URI&amp; uri, const std::string&amp; text, Poco::UInt32 width = 0, Poco::UInt32 height = 0);
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>image
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>alt: mandatory, alternative text to display when image is not found </li>
<li>src: mandatory, URL of the image </li>
<li>width: optional, width in pixel, default = 0, if set to 0, the original size of the image is used </li>
<li>height: optional, height in pixel, default = 0, if set to 0, the original size of the image is used </li>
<li>class: optional, if not set <i>image</i> is used </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;image id=&quot;i1&quot; alt=&quot;Micro Image&quot; title=&quot;Micro sized Image&quot; src=&quot;http://appinf.com/poco/images/PocoLayers.jpg&quot; width=&quot;20&quot; height=&quot;16&quot;/&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;img alt=&quot;Micro Image&quot; class=&quot;image&quot; height=&quot;16&quot; id=&quot;i1&quot; src=&quot;http://appinf.com/poco/images/PocoLayers.jpg&quot; title=&quot;Micro sized Image&quot; width=&quot;20&quot;/&gt;
</pre>
<p> </p> <img alt="Micro Image" class="image" height="16" id="i1" src="http://appinf.com/poco/images/PocoLayers.jpg" title="Micro sized Image" width="20"/> <p> </p>
<p></p><h3>ImageButton</h3><p>
An Imagebutton is basically a standard Button displaying an image instead of a text. </p>
<p></p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>ImageButton(const Poco::URI&amp; img, const std::string&amp; alternativeText, Poco::UInt32 width = 0, Poco::UInt32 height = 0);
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>imageButton
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>text: mandatory, alternative text to display when image is not found </li>
<li>img: mandatory, URL of the image </li>
<li>width: optional, width in pixel, default = 0, if set to 0, the original size of the image is used </li>
<li>height: optional, height in pixel, default = 0, if set to 0, the original size of the image is used </li>
<li>class: optional, if not set <i>imagebutton</i> is used </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;imageButton id=&quot;i1&quot; text=&quot;Micro Image&quot; img=&quot;http://appinf.com/poco/images/PocoLayers.jpg&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;input alt=&quot;Micro Image&quot; class=&quot;imagebutton&quot; height=&quot;30&quot; id=&quot;i1&quot; src=&quot;http://appinf.com/poco/images/PocoLayers.jpg&quot; type=&quot;image&quot; width=&quot;30&quot;/&gt;
</pre>
<p> </p> <input alt="Micro Image" class="imagebutton" height="30" id="i1" src="http://appinf.com/poco/images/PocoLayers.jpg" type="image" width="30"/> <p> </p>
<p></p>
<p></p><h3>Label</h3><p>
Use this class to add text to your GUI. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>Label(const std::string&amp; txt);
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>label
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
No attributes. </p>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;label&gt;Hello&lt;/label&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>Hello
</pre>
<p> Hello </p>
<p></p><h3>ListView</h3><p>
A ListView offers a scrollable list of selectable targets. As targets only labels are valid, non-labels are ignored. Multi-selection is possible. Indices start with 0. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>ListView(const std::string&amp; uniqueName, 
         int viewSize, 
         bool multiple, 
         const std::vector&lt;Poco::AutoPtr&lt;Label&gt; &gt;&amp; children = std::vector&lt;Poco::AutoPtr&lt;Label&gt; &gt;());
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>listView
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>name: mandatory, the name of the ListView </li>
<li>multiple: optional, value=[true|false], default = false, determines if multiple selection is allowed </li>
<li>select: optional, a space separated list of item positions </li>
<li>size: mandatory, how many items are displayed </li>
<li>class: optional, if not set, <i>listview</i> is used. </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;listView id=&quot;v1&quot; name=&quot;list&quot; size=&quot;3&quot; multiple=&quot;true&quot; select=&quot;0 2 4&quot;&gt;
    &lt;label&gt;1st&lt;/label&gt;
    &lt;label&gt;2nd&lt;/label&gt;
    &lt;label&gt;3rd&lt;/label&gt;
    &lt;label&gt;4th&lt;/label&gt;
    &lt;label&gt;5th&lt;/label&gt;
    &lt;label&gt;6th&lt;/label&gt;
&lt;/listView&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;select class=&quot;listview&quot; id=&quot;v1&quot; multiple=&quot;multiple&quot; name=&quot;list&quot; size=&quot;3&quot;&gt;
    &lt;option selected=&quot;selected&quot;&gt;1st&lt;/option&gt;
    &lt;option&gt;2nd&lt;/option&gt;
    &lt;option selected=&quot;selected&quot;&gt;3rd&lt;/option&gt;
    &lt;option&gt;4th&lt;/option&gt;
    &lt;option selected=&quot;selected&quot;&gt;5th&lt;/option&gt;
    &lt;option&gt;6th&lt;/option&gt;
&lt;/select&gt;
</pre>
<p> </p>
<p></p> <select class="listview" id="v1" multiple="multiple" name="list" size="3"> <option selected="selected">1st</option> <option>2nd</option> <option selected="selected">3rd</option> <option>4th</option> <option selected="selected">5th</option> <option>6th</option> </select> <p> </p>
<p></p><h3>PwdField</h3><p>
A text field to read passwords. </p>
<p></p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>PwdField(const std::string&amp; uniqueName, Poco::UInt32 size, Poco::UInt32 maxLength);
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>pwdField
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>name: mandatory, the name of the PwdField </li>
<li>maxLength: optional, the maximum size of the typed in string </li>
<li>size: optional, the size of the GUI element in characters </li>
<li>class: optional, if not set, <i>password</i> is used. </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;pwdField id=&quot;i1&quot; size=&quot;20&quot; maxLength=&quot;40&quot; name=&quot;pwdField&quot;/&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;input class=&quot;password&quot; id=&quot;i1&quot; maxlength=&quot;40&quot; name=&quot;pwdField&quot; size=&quot;20&quot; type=&quot;password&quot;/&gt;
</pre>
<p> </p>
<p></p> <input class="password" id="i1" maxlength="40" name="pwdField" size="20" type="password"/> <p> </p>
<p></p><h3>RadioButton</h3><p>
A RadioButton is a member of a button group. Only one can be selected of a group. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>RadioButton(const std::string&amp; group, const std::string&amp; text, bool checked=false);
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>radioButton
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>name: mandatory, must not be empty, must be unique inside the used form </li>
<li>checked: optional, values = [true|false], default = false </li>
<li>class: optional, when not set <i> checkbox </i> is used </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;radioButton id=&quot;b1&quot; name=&quot;radio&quot; checked=&quot;false&quot;&gt;Click me&lt;/radioButton&gt;
&lt;radioButton id=&quot;b2&quot; name=&quot;radio&quot; checked=&quot;true&quot;&gt;No! Click Me!&lt;/radioButton&gt;
</pre>
<p> </p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;input class=&quot;radiobutton&quot; id=&quot;b1&quot; name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;Click me&quot;/&gt;Click me&lt;br&gt;
&lt;input checked=&quot;checked&quot; class=&quot;radiobutton&quot; id=&quot;b2&quot; name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;No! Click Me!&quot;/&gt;No! Click Me!
</pre>
<p> </p>
<p></p> <input class="radiobutton" id="b1" name="radio" type="radio" value="Click me"/>Click me<br> <input checked="checked" class="radiobutton" id="b2" name="radio" type="radio" value="No! Click Me!"/>No! Click Me! <p> </p>
<p></p>
<p></p><h3>StackPanel</h3><p>
A StackPanel contains a list of Widgets which are rendered on top of each other </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>StackPanel(const std::vector&lt;Poco::AutoPtr&lt;Widget&gt; &gt;&amp; children = std::vector&lt;Poco::AutoPtr&lt;Widget&gt; &gt;());
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>stack
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
No attributes. </p>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;stack&gt;
    &lt;label&gt;Test Label&lt;/label&gt;
    &lt;label&gt;2nd label&lt;/label&gt;
    &lt;label&gt;3rd label&lt;/label&gt;
&lt;/stack&gt;
</pre>
<p> </p>
<p></p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>Test Label&lt;br&gt;2nd label&lt;br&gt;3rd label
</pre>
<p> </p>
<p></p> Test Label<br>2nd label<br>3rd label <p> </p>
<p></p><h3>Table</h3><p>
A Table stores a matrix of Widgets. A Table must have a column size, can have a maximum row count, can have a <i>header</i>, a <i>footer</i> and a <i>body</i>. For each of the last three elements separate attributes can be set. </p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>Table(Poco::UInt32 numRows, 
      Poco::UInt32 numCols, 
      bool tableHasFooter, 
      bool tableHasHeader = true, 
      Poco::UInt32 borderStrength = 0, 
      Poco::UInt32 width = 0);
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>table
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>cols: mandatory, how many columns has the table </li>
<li>rows: optional, if set will truncate/resize the table to that size </li>
<li>border: optional, size of the border around the table in pixel, default = 0 </li>
<li>header: optional, value=[true|false], should the very first line of the table be treated as a header, default = true </li>
<li>footer: optional, value=[true|false], should the last line of the table be treated as a footer, default = false </li>
<li>width: optional, the width of the table in pixel, currently UNSUPPORTED </li>
</ul>
<p></p>
<p></p><h4>XML Example</h4><p>
Note that a table consists of cells. Each cell can have a row and col index. Indices start with 0. If one of these values is not present, the last value will be taken and incremented if necessary. </p>
<p></p>
<pre>&lt;table id=&quot;i1&quot; border=&quot;1&quot; cols=&quot;3&quot;&gt;
    &lt;cell&gt;
        &lt;stack&gt;
            &lt;radioButton id=&quot;i2&quot; name=&quot;radio&quot;&gt;Click me&lt;/radioButton&gt;
            &lt;radioButton id=&quot;i3&quot; name=&quot;radio&quot;&gt;&lt;![CDATA[&lt;b&gt;No! Click Me!&lt;/b&gt;]]&gt;&lt;/radioButton&gt;
        &lt;/stack&gt;
    &lt;/cell&gt;
    &lt;cell&gt;
        &lt;stack&gt;
            &lt;checkBox id=&quot;i4&quot; name=&quot;check&quot;&gt;Check This&lt;/checkBox&gt;
            &lt;checkBox id=&quot;i5&quot; name=&quot;check&quot;&gt;Check That&lt;/checkBox&gt;
        &lt;/stack&gt;
    &lt;/cell&gt;
    &lt;!-- the third column has no value --&gt;
    &lt;cell row=&quot;1&quot;&gt;
        &lt;stack&gt;
            &lt;label&gt;A Text Area&lt;/label&gt;
            &lt;textArea id=&quot;i6&quot; rows=&quot;10&quot; cols=&quot;30&quot; name=&quot;textArea&quot;/&gt;
        &lt;/stack&gt;    
    &lt;/cell&gt;
    &lt;cell col=&quot;2&quot;&gt;
        &lt;flow&gt;
            &lt;label&gt;A Text Field:&lt;/label&gt;
            &lt;textField id=&quot;i7&quot; size=&quot;20&quot; maxLength=&quot;40&quot; name=&quot;textField&quot;/&gt;
        &lt;/flow&gt; 
    &lt;/cell&gt;
&lt;/table&gt;
</pre>
<p> </p>
<p></p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;table border=&quot;1&quot; class=&quot;table&quot; id=&quot;i1&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;
                &lt;input class=&quot;radiobutton&quot; id=&quot;i2&quot; name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;Click me&quot;/&gt;Click me&lt;br&gt;
                &lt;input class=&quot;radiobutton&quot; id=&quot;i3&quot; name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;No! Click Me!&quot;/&gt;No! Click Me!
            &lt;/th&gt;
            &lt;th&gt;
                &lt;input class=&quot;checkbox&quot; id=&quot;i4&quot; name=&quot;check&quot; type=&quot;checkbox&quot; value=&quot;Check This&quot;/&gt;Check This&lt;br&gt;
                &lt;input class=&quot;checkbox&quot; id=&quot;i5&quot; name=&quot;check&quot; type=&quot;checkbox&quot; value=&quot;Check That&quot;/&gt;Check That&lt;/th&gt;
            &lt;th&gt;
                &amp;nbsp;
            &lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;
                A Text Area&lt;br&gt;
                &lt;textarea class=&quot;textarea&quot; cols=&quot;30&quot; id=&quot;i6&quot; name=&quot;textArea&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;
            &lt;/td&gt;
            &lt;td&gt;
                &amp;nbsp;
            &lt;/td&gt;
            &lt;td&gt;
                &lt;a&gt;A Text Field:&lt;/a&gt;
                &lt;a&gt;&lt;input class=&quot;textfield&quot; id=&quot;i7&quot; maxlength=&quot;40&quot; name=&quot;textField&quot; size=&quot;20&quot; type=&quot;text&quot;/&gt;&lt;/a&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</pre>
<p> </p>
<p></p> <table border="1" class="table" id="i1"> <thead> <tr> <th> <input class="radiobutton" id="i2" name="radio" type="radio" value="Click me"/>Click me<br> <input class="radiobutton" id="i3" name="radio" type="radio" value="No! Click Me!"/>No! Click Me! </th> <th> <input class="checkbox" id="i4" name="check" type="checkbox" value="Check This"/>Check This<br> <input class="checkbox" id="i5" name="check" type="checkbox" value="Check That"/>Check That</th> <th> &nbsp; </th> </tr> </thead> <tbody> <tr> <td> A Text Area<br> <textarea class="textarea" cols="30" id="i6" name="textArea" rows="10"></textarea> </td> <td> &nbsp; </td> <td> <a>A Text Field:</a> <a><input class="textfield" id="i7" maxlength="40" name="textField" size="20" type="text"/></a> </td> </tr> </tbody> </table> <p> </p>
<p></p><h3>TextArea</h3><p>
A TextArea is a multi-line text field. Note that any default text will show up in the TextArea as entered in the XML file, i.e. with line breaks and tabs. </p>
<p></p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>TextArea(const std::string&amp; uniqueName, 
         Poco::UInt32 rows, 
         Poco::UInt32 cols, 
         const std::string&amp; defTxt = std::string());
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>textArea
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>name: mandatory </li>
<li>rows: mandatory, the width of the textfield in characters </li>
<li>cols: mandatory, the height of the textfield in characters </li>
<li>class: optional, if empty <i>textarea</i> will be used </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;textArea id=&quot;i6&quot; rows=&quot;10&quot; cols=&quot;30&quot; name=&quot;textArea&quot;&gt;default text&lt;/textArea&gt;
</pre>
<p> </p>
<p></p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;textarea class=&quot;textarea&quot; cols=&quot;30&quot; id=&quot;i6&quot; name=&quot;textArea&quot; rows=&quot;10&quot;&gt;default text&lt;/textarea&gt;
</pre>
<p> </p>
<p></p> <textarea class="textarea" cols="30" id="i6" name="textArea" rows="10">default text</textarea> <p> </p>
<p></p>
<p></p><h3>TextField</h3><p>
A TextField is a single-line text field. </p>
<p></p>
<p></p><h4>C++ Code</h4><p>
</p>
<pre>TextField(const std::string&amp; uniqueName, 
          Poco::UInt32 size, 
          Poco::UInt32 maxLength, 
          const std::string&amp; defTxt = std::string());
</pre>
<p> </p>
<p></p><h4>XML Keyword</h4><p>
</p>
<pre>textField
</pre>
<p> </p>
<p></p><h4>XML Attributes</h4><p>
</p>
<ul>
<li>name: mandatory </li>
<li>size: mandatory, the width of the textfield in characters </li>
<li>maxLength: optional, the maximum length of the string one can type </li>
<li>class: optional, if empty <i>textfield</i> will be used </li>
</ul>
<p></p><h4>XML Example</h4><p>
</p>
<pre>&lt;textField id=&quot;i7&quot; size=&quot;20&quot; maxLength=&quot;40&quot; name=&quot;textField&quot;&gt;default text&lt;/textField&gt;
</pre>
<p> </p>
<p></p>
<p></p><h4>HTML Code</h4><p>
</p>
<pre>&lt;input class=&quot;textfield&quot; id=&quot;i7&quot; maxlength=&quot;40&quot; name=&quot;textField&quot; size=&quot;20&quot; type=&quot;text&quot; value=&quot;default text&quot;/&gt;
</pre>
<p> </p>
<p></p> <input class="textfield" id="i7" maxlength="40" name="textField" size="20" type="text" value="default text"/> <p> </p>
<p></p><h2>Registering pages at URLs</h2><p>
The WebWidgets project comes with a pre-defined HTTPRequestHandlerFactory named Poco::WebWidgets::WidgetHandlerFactory. To get a WebWidgets application up and running follow these steps: </p>
<ul>
<li>create the WidgetHandlerFactory </li>
<li>load/create your widgets </li>
<li>register for events if required </li>
<li>register the widgets at the WidgetHandlerFactory </li>
<li>start a HTTPServer with the WidgetHandlerFactory </li>
<li>make sure that appinf.js is in the root dir of the server! </li>
</ul>
<p>Example: </p>
<pre>unsigned short port = (unsigned short) config().getInt(&quot;HTTPFormServer.port&quot;, 9980);

// set-up a server socket
ServerSocket svs(port);
// set-up a HTTPServer instance
Poco::URI root(&quot;/&quot;);

// create the WidgetHandlerFactory
WidgetHandlerFactory* pFac = new WidgetHandlerFactory();  

// load/create your widgets
std::ifstream in(&quot;Order.xml&quot;);
Poco::AutoPtr&lt;Widget&gt; ptrWidget = XMLUtil::loadWidget(in);

// register for events if required
Poco::AutoPtr&lt;Widget&gt; ptrSubmitButton = ptrWidget-&gt;find(&quot;submit&quot;);
poco_assert (ptrSubmitButton);
ptrSubmitButton-&gt;ESingleClick += delegate(this, &amp;MyServerApp:onOrderClicked);

// register the widgets at the WidgetHandlerFactory
pFac-&gt;addWidget(root, ptrWidget);
HTTPServer srv(pFac, svs, new HTTPServerParams);
// start the HTTPServer
srv.start();
// wait for CTRL-C or kill
waitForTerminationRequest();
// Stop the HTTPServer
srv.stop();
return Application::EXIT_OK;
</pre>
<p> </p>
<p>Note that the WidgetHandlerFactory is still incomplete. At least a possibility to add ones own HTTPRequestHandler for a given URI is required! </p>
<p></p>
</div>
<p class="footer">C++ Portable Components 1.0<br />
Copyright &copy; 2007, <a href="http://www.appinf.com/" target="_blank">Applied Informatics</a></p>
</body>
</html>
