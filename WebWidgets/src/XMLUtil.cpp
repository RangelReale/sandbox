//
// XMLUtil.cpp
//
// $Id: //poco/Main/WebWidgets/src/XMLUtil.cpp#4 $
//
// Library: WebWidgets
// Package: WebParser
// Module:  XMLUtil
//
// Copyright (c) 2007, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/WebWidgets/XMLUtil.h"
#include "Poco/WebWidgets/Parser.h"
#include "Poco/WebWidgets/HTMLVisitor.h"
#include "Poco/DOM/NodeList.h"
#include "Poco/DOM/DOMParser.h"
#include "Poco/DOM/Document.h"
#include "Poco/DOM/NodeIterator.h"
#include "Poco/DOM/NodeFilter.h"
#include "Poco/SAX/InputSource.h"
#include "Poco/String.h"


namespace Poco {
namespace WebWidgets {


const std::string XMLUtil::VAL_TRUE("true");
const std::string XMLUtil::VAL_FALSE("false");
const std::string XMLUtil::TAG_EVENTS("events");
const std::string XMLUtil::TAG_DELEGATE("delegate");
const std::string XMLUtil::ATTR_FUNCTION("function");
const std::string XMLUtil::ATTR_FILE("file");


Poco::AutoPtr<Widget> XMLUtil::loadWidget(std::istream& in)
{
	Poco::XML::InputSource src(in);
	Poco::XML::DOMParser parser;
	Poco::AutoPtr<Poco::XML::Document> pDoc = parser.parse(&src);
	Poco::XML::Element* pRoot = pDoc->documentElement();
	Poco::AutoPtr<Widget> ptrRoot = Parser::instance().load(pRoot);
	poco_assert (ptrRoot);
	return ptrRoot;
}


std::vector<const Poco::XML::Element*> XMLUtil::getAllElementChildren(const Poco::XML::Element* pElem)
{
	std::vector<const Poco::XML::Element*> result;
	const Poco::XML::Node* pParent = pElem;

	Poco::AutoPtr<Poco::XML::NodeList> ptrNL = pElem->childNodes();
	if (ptrNL && ptrNL->length() > 0)
	{
		for (unsigned long i = 0; i < ptrNL->length(); ++i)
		{
			Poco::XML::Node* pNode = ptrNL->item(i);
			if (pNode && pNode->nodeType() == Poco::XML::Node::ELEMENT_NODE && pNode->parentNode() == pParent && pElem->tagName() != TAG_EVENTS)
			{
				result.push_back(static_cast<Poco::XML::Element*>(pNode));
			}
		}
	}

	return result;
}


std::vector<const Poco::XML::Element*> XMLUtil::getNamedElementChildren(const Poco::XML::Element* pElem, const std::string& tagName)
{
	std::vector<const Poco::XML::Element*> result;
	const Poco::XML::Node* pParent = pElem;

	Poco::AutoPtr<Poco::XML::NodeList> ptrNL = pElem->childNodes();
	if (ptrNL && ptrNL->length() > 0)
	{
		for (unsigned long i = 0; i < ptrNL->length(); ++i)
		{
			Poco::XML::Node* pNode = ptrNL->item(i);
			if (pNode && pNode->nodeType() == Poco::XML::Node::ELEMENT_NODE && pNode->parentNode() == pParent)
			{
				Poco::XML::Element* pElem = static_cast<Poco::XML::Element*>(pNode);
				if (pElem->tagName() == tagName)
					result.push_back(pElem);
			}
		}
	}

	return result;
}


const Poco::XML::Element* XMLUtil::getEvents(const Poco::XML::Element* pElem)
{
	std::vector<const Poco::XML::Element*> result = getNamedElementChildren(pElem, TAG_EVENTS);
	if (result.size() > 1)
		throw Poco::DataFormatException("XML node is only allowed to contain one single " + TAG_EVENTS + "child!");
	if (result.empty())
		return 0;
	return result[0];
}


std::vector<Poco::AutoPtr<Widget> > XMLUtil::getAllWidgets(const Poco::XML::Element* pElem, Widget* pParent)
{
	std::vector<Poco::AutoPtr<Widget> > result;
	std::vector<const Poco::XML::Element*> tmp = XMLUtil::getAllElementChildren(pElem);
	std::vector<const Poco::XML::Element*>::const_iterator it = tmp.begin();
	std::vector<const Poco::XML::Element*>::const_iterator itEnd = tmp.end();
	for (; it != itEnd; ++it)
	{
		result.push_back(XMLUtil::createWidget(*it, pParent));
	}
	return result;
}


std::vector<Poco::AutoPtr<Widget> > XMLUtil::getWidgets(const Poco::XML::Element* pElem, const std::string& childName, Widget* pParent)
{
	std::vector<Poco::AutoPtr<Widget> > result;
	std::vector<const Poco::XML::Element*> tmp = XMLUtil::getNamedElementChildren(pElem, childName);
	std::vector<const Poco::XML::Element*>::const_iterator it = tmp.begin();
	std::vector<const Poco::XML::Element*>::const_iterator itEnd = tmp.end();
	for (; it != itEnd; ++it)
	{
		result.push_back(XMLUtil::createWidget(*it, pParent));
	}
	return result;
}

Poco::AutoPtr<Widget> XMLUtil::createWidget(const Poco::XML::Element* pElem, Widget* pParent)
{
	Poco::AutoPtr<Widget> result = Parser::instance().load(pElem);
	result->setParent(pParent);
	const Poco::XML::Element* pEv = getEvents(pElem);
	if (pEv)
	{
		initEvents(*result, pEv);
	}
	return result;
}


std::string XMLUtil::getText(const Poco::XML::Element* pElem)
{
	return Poco::trim(pElem->innerText());
}


bool XMLUtil::getBoolAttr(const Poco::XML::Element* pElem , const std::string& attrName)
{
	std::string val = Poco::toLower(pElem->getAttribute(attrName));

	if (val == VAL_TRUE)
		return true;
	if (val == VAL_FALSE)
		return false;
	throw Poco::SyntaxException("Illegal boolean value " + val);
}


bool XMLUtil::getBoolAttr(const Poco::XML::Element* pElem , const std::string& attrName, bool defaultValue)
{
	std::string val = Poco::toLower(pElem->getAttribute(attrName));

	if (val == VAL_TRUE)
		return true;
	if (val == VAL_FALSE)
		return false;
	
	return defaultValue;
}


void XMLUtil::initEvents(Widget& widget, const Poco::XML::Element* pEvents)
{
	poco_check_ptr (pEvents);
	poco_assert (pEvents->tagName() == TAG_EVENTS);
	//<onclick>
	//	<delegate file="appinf.js" function="invoke"/>
	//	<delegate file="appinf.js" function="alarm"/>
	//</onclick>

	std::vector<JSDelegate> result;
	getEventDelegates(pEvents, HTMLVisitor::EVENT_SINGLECLICK, result);
	add(widget.ESingleClick, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_DOUBLECLICK, result);
	add(widget.EDoubleClick, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_MOUSEDOWN, result);
	add(widget.EMouseDown, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_MOUSEUP, result);
	add(widget.EMouseUp, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_MOUSEOVER, result);
	add(widget.EMouseOver, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_MOUSEOUT, result);
	add(widget.EMouseOut, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_MOUSEMOVE, result);
	add(widget.EMouseMove, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_FOCUSENTER, result);
	add(widget.EFocusEnter, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_FOCUSLOST, result);
	add(widget.EFocusLost, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_KEYUP, result);
	add(widget.EKeyUp, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_KEYDOWN, result);
	add(widget.EKeyDown, result);
	getEventDelegates(pEvents, HTMLVisitor::EVENT_KEYPRESSED, result);
	add(widget.EKeyPressed, result);
	InputField* pInput = dynamic_cast<InputField*>(&widget);
	if (pInput)
	{
		getEventDelegates(pEvents, HTMLVisitor::EVENT_SELECT, result);
		add(pInput->ESelect, result);
		getEventDelegates(pEvents, HTMLVisitor::EVENT_CHANGE, result);
		add(pInput->EChange, result);
	}
}


void XMLUtil::getEventDelegates(const Poco::XML::Element* pEvents, const std::string& tagName, std::vector<JSDelegate>& result)
{
	result.clear();
	std::vector<const Poco::XML::Element*> vecOnEvent = XMLUtil::getNamedElementChildren(pEvents, tagName);
	std::vector<const Poco::XML::Element*>::const_iterator it = vecOnEvent.begin();
	std::vector<const Poco::XML::Element*>::const_iterator itEnd = vecOnEvent.end();
	for (; it != itEnd; ++it)
	{
		std::vector<const Poco::XML::Element*> dels = XMLUtil::getNamedElementChildren(*it, TAG_DELEGATE);
		createDelegates(dels, result);
	}
}


void XMLUtil::createDelegates(const std::vector<const Poco::XML::Element*>& xml, std::vector<JSDelegate>& result)
{
	std::vector<const Poco::XML::Element*>::const_iterator it = xml.begin();
	std::vector<const Poco::XML::Element*>::const_iterator itEnd = xml.end();
	for (; it != itEnd; ++it)
	{
		poco_assert_dbg((*it)->tagName() == TAG_DELEGATE);
		std::string fct = (*it)->getAttribute(ATTR_FUNCTION);
		std::string file = (*it)->getAttribute(ATTR_FILE);
		result.push_back(JSDelegate(fct, file));
	}
}


} } // namespace Poco::WebWidgets
