//
// Table.cpp
//
// $Id: //poco/Main/WebWidgets/src/Table.cpp#4 $
//
// Library: WebWidgets
// Package: WebGUI
// Module:  Table
//
// Copyright (c) 2007, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/WebWidgets/Table.h"
#include "Poco/WebWidgets/Visitor.h"
#include "Poco/WebWidgets/XMLUtil.h"
#include "Poco/Exception.h"
#include "Poco/NumberFormatter.h"
#include "Poco/NumberParser.h"
#include "Poco/String.h"
#include "Poco/DOM/Element.h"


namespace Poco {
namespace WebWidgets {


const std::string Table::FACTORY_ID("table");
const std::string Table::XML_WIDTH("width");
const std::string Table::XML_BORDER("border");
const std::string Table::XML_HEADER("header");
const std::string Table::XML_BODY("body");
const std::string Table::XML_FOOTER("footer");
const std::string Table::VAL_COLS("cols");
const std::string Table::VAL_ROWS("rows");
const std::string Table::VAL_COL("col");
const std::string Table::VAL_ROW("row");
const std::string Table::VAL_CELL("cell");
const std::string Table::VAL_TABLEFOOTER("footer");


Table::Table(Poco::UInt32 numRows, Poco::UInt32 numCols, bool tableHasFooter, bool tableHasHeader, Poco::UInt32 borderStrength, Poco::UInt32 width):
	_cols(numCols),
	_border(borderStrength),
	_width(width),
	_tableHasFooter(tableHasFooter),
	_tableHasHeader(tableHasHeader),
	_table(numRows, Row(numCols, Poco::AutoPtr<Widget>())),
	_headerAttr(),
	_bodyAttr(),
	_footerAttr()
{
	addAttribute(XML_BORDER, Poco::NumberFormatter::format(_border));
	if (_width > 0)
		addAttribute(XML_WIDTH, Poco::NumberFormatter::format(_width));
	poco_assert (_cols > 0);
}


Table::Table(const Poco::XML::Element* pElem):
	Panel(pElem),
	_cols(XMLUtil::getNumericAttrUnsigned<Poco::UInt32>(pElem, VAL_COLS)),
	_border(XMLUtil::getNumericAttrUnsigned<Poco::UInt32>(pElem, XML_BORDER, 0)),
	_width(XMLUtil::getNumericAttrUnsigned<Poco::UInt32>(pElem, XML_WIDTH, 0)),
	_tableHasFooter(XMLUtil::getBoolAttr(pElem, VAL_TABLEFOOTER, false)),
	_tableHasHeader(XMLUtil::getBoolAttr(pElem, XML_HEADER, true)),
	_table(),
	_headerAttr(),
	_bodyAttr(),
	_footerAttr()
{
	Poco::UInt32 rows = 0;
	bool rowsDefined = false;
	std::string tmp = pElem->getAttribute(VAL_ROWS);
	if (!tmp.empty())
	{
		rows = Poco::NumberParser::parseUnsigned(tmp);
		_table.resize(rows, Row(_cols, Poco::AutoPtr<Widget>()));
		rowsDefined = true;
	}

	addAttribute(XML_BORDER, Poco::NumberFormatter::format(_border));

	// now parse the children of a table
	std::vector<const Poco::XML::Element*> cells = XMLUtil::getNamedElementChildren(pElem, VAL_CELL);
	std::vector<const Poco::XML::Element*>::const_iterator it = cells.begin();
	std::vector<const Poco::XML::Element*>::const_iterator itEnd = cells.end();
	Poco::UInt32 row(0); 
	Poco::UInt32 col(0);
	for (; it != itEnd; ++it)
	{
		Poco::UInt32 rowAttr(row);
		tmp = (*it)->getAttribute(VAL_ROW);
		if (!tmp.empty())
		{
			rowAttr = Poco::NumberParser::parseUnsigned(tmp);
			if (rowAttr != row)
				col = 0;
			row = rowAttr;
			tmp = (*it)->getAttribute(VAL_COL);
			if (!tmp.empty())
			{
				col = Poco::NumberParser::parseUnsigned(tmp);
			}
		}
		else
		{
			// no row defined, check overflow
			tmp = (*it)->getAttribute(VAL_COL);
			if (!tmp.empty())
			{
				col = Poco::NumberParser::parseUnsigned(tmp);
			}
			else
			{
				// no column defined
				if (col == numberOfColumns())
				{
					col = 0;
					++row;
				}
			}
		}
		// createWidget
		if (!rowsDefined)
		{
			// auto increment
			if (numberOfRows() <= row)
				_table.resize(row+1, Row(_cols, Poco::AutoPtr<Widget>()));
		}

		std::vector<const Poco::XML::Element*> cellChild = XMLUtil::getAllElementChildren(*it);
		if (cellChild.size() > 1)
			throw Poco::SyntaxException("A cell can only have one single child!");
		else if (cellChild.size() == 1)
		{
			Poco::AutoPtr<Widget> ptrWidget = XMLUtil::createWidget(cellChild[0], this);
			addWidget(row, col, ptrWidget);
		}
		// no content is valid
		++col;
	}

	// extract header element
	std::vector<const Poco::XML::Element*> hdr = XMLUtil::getNamedElementChildren(pElem, XML_HEADER);
	if (hdr.size() > 1)
		throw Poco::SyntaxException("A Table can only have one single header!");
	if (hdr.size() == 1)
		Widget::parseUniversalAttributes(hdr[0], _headerAttr);
	// extract body element
	hdr = XMLUtil::getNamedElementChildren(pElem, XML_BODY);
	if (hdr.size() > 1)
		throw Poco::SyntaxException("A Table can only have one single body!");
	if (hdr.size() == 1)
		Widget::parseUniversalAttributes(hdr[0], _bodyAttr);

	hdr = XMLUtil::getNamedElementChildren(pElem, XML_FOOTER);
	if (hdr.size() > 1)
		throw Poco::SyntaxException("A Table can only have one single footer!");
	if (hdr.size() == 1)
		Widget::parseUniversalAttributes(hdr[0], _footerAttr);
}


Table::~Table()
{
}


void Table::addWidget(Poco::UInt32 row, Poco::UInt32 col, Poco::AutoPtr<Widget> ptrWidget)
{
	if (row >= _table.size() || col >= _cols)
		throw InvalidAccessException("Setting Widget outside of table boundaries");
	_table[row][col] = ptrWidget;
}


Poco::AutoPtr<Widget> Table::removeWidget(Poco::UInt32 row, Poco::UInt32 col)
{
	Poco::AutoPtr<Widget> res;
	if (row < _table.size() && col < _cols)
		res = _table[row][col];

	return res;
}


Poco::AutoPtr<Widget> Table::getWidget(Poco::UInt32 row, Poco::UInt32 col) const
{
	if (row >= _table.size() || col >= _cols)
		throw InvalidAccessException("Setting Widget outside of table boundaries");
	return _table[row][col];
}


void Table::appendRow(const Row& aRow)
{
	if (aRow.size() != _cols)
		throw InvalidArgumentException("Column count differs");
	_table.push_back(aRow);
}


void Table::accept(Visitor& v)
{
	v.visit(*this);
}


Poco::AutoPtr<Widget> Table::find(const std::string& id) const
{
	Content::const_iterator it = _table.begin();
	Content::const_iterator itEnd = _table.end();
	Poco::AutoPtr<Widget> res;
	for (; it != itEnd; ++it)
	{
		Row::const_iterator itRow = it->begin();
		Row::const_iterator itRowEnd = it->end();
		for (; itRow != itRowEnd && res.isNull(); ++itRow)
		{
			res = Widget::find(*itRow, id);
		}
	}

	return res;
}


Poco::AutoPtr<Widget> Table::clone() const
{
	Poco::AutoPtr<Table> ptr = new Table(0xffffffffu, static_cast<Poco::UInt32>(_cols), _tableHasFooter, _tableHasHeader, _border, _width);
	ptr->setAttributes(getAttributes());
	ptr->_bodyAttr = _bodyAttr;
	ptr->_footerAttr = _footerAttr;
	ptr->_headerAttr = _headerAttr;
	Content& table = ptr->_table;
	Content::const_iterator it = _table.begin();
	Content::const_iterator itEnd = _table.end();
	for (; it != itEnd; ++it)
	{
		table.push_back(Row());
		Content::iterator itInRow = (--table.end());
		Row::const_iterator itRow = it->begin();
		Row::const_iterator itRowEnd = it->end();
		for (; itRow != itRowEnd; ++itRow)
		{
			if ((*itRow))
			{
				Poco::AutoPtr<Widget> ptrChild = (*itRow)->clone();
				ptrChild->setParent(ptr);
				itInRow->push_back(ptrChild);
			}
			else
				itInRow->push_back(Poco::AutoPtr<Widget>());
		}
	}

	return ptr;
}


} } // namespace Poco::WebWidgets
