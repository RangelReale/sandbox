//
// HTMLVisitor.cpp
//
// $Id: //poco/Main/WebWidgets/src/HTMLVisitor.cpp#9 $
//
// Library: WebWidgets
// Package: WebVisitor
// Module:  HTMLVisitor
//
// Copyright (c) 2007, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/WebWidgets/HTMLVisitor.h"
#include "Poco/WebWidgets/Label.h"
#include "Poco/WebWidgets/HTML.h"
#include "Poco/WebWidgets/Form.h"
#include "Poco/WebWidgets/RootPanel.h"
#include "Poco/WebWidgets/Image.h"
#include "Poco/WebWidgets/FlowPanel.h"
#include "Poco/WebWidgets/SimplePanel.h"
#include "Poco/WebWidgets/Table.h"
#include "Poco/WebWidgets/HyperLink.h"
#include "Poco/WebWidgets/Button.h"
#include "Poco/WebWidgets/ImageButton.h"
#include "Poco/WebWidgets/TextArea.h"
#include "Poco/WebWidgets/TextField.h"
#include "Poco/WebWidgets/CheckBox.h"
#include "Poco/WebWidgets/RadioButton.h"
#include "Poco/WebWidgets/IndexedPanel.h"
#include "Poco/WebWidgets/StackPanel.h"
#include "Poco/WebWidgets/ComboBox.h"
#include "Poco/WebWidgets/ListView.h"
#include "Poco/WebWidgets/HidablePanel.h"
#include "Poco/WebWidgets/PwdField.h"
#include "Poco/NumberFormatter.h"
#include <algorithm>
#include <iostream>


namespace Poco {
namespace WebWidgets {


const std::string HTMLVisitor::TAG_DIV("div");
const std::string HTMLVisitor::TAG_HTML("html");
const std::string HTMLVisitor::TAG_HEAD("head");
const std::string HTMLVisitor::TAG_TABLE("table");
const std::string HTMLVisitor::TAG_THEAD("thead");
const std::string HTMLVisitor::TAG_TBODY("tbody");
const std::string HTMLVisitor::TAG_TFOOT("tfoot");
const std::string HTMLVisitor::TAG_TITLE("title");
const std::string HTMLVisitor::TAG_IMG("img");
const std::string HTMLVisitor::TAG_BODY("body");
const std::string HTMLVisitor::TAG_PRE("pre");
const std::string HTMLVisitor::TAG_A("a");
const std::string HTMLVisitor::TAG_INPUT("input");
const std::string HTMLVisitor::TAG_TEXTAREA("textarea");
const std::string HTMLVisitor::TAG_FORM("form");
const std::string HTMLVisitor::TAG_SELECT("select");
const std::string HTMLVisitor::TAG_OPTION("option");
const std::string HTMLVisitor::PRE_OPEN("<");
const std::string HTMLVisitor::PRE_CLOSE("</");
const std::string HTMLVisitor::CLOSE(">");
const std::string HTMLVisitor::FULLCLOSE("/>");
const std::string HTMLVisitor::VAL_SPACE(" ");
const std::string HTMLVisitor::VAL_TABLECELLEMPTY("&nbsp;");
const std::string HTMLVisitor::VAL_SUBMIT("submit");
const std::string HTMLVisitor::VAL_RESET("reset");
const std::string HTMLVisitor::VAL_IMAGE("image");
const std::string HTMLVisitor::VAL_TEXT("text");
const std::string HTMLVisitor::VAL_ONCLICK("onClick");
const std::string HTMLVisitor::VAL_CHECKBOX("checkbox");
const std::string HTMLVisitor::VAL_RADIO("radio");
const std::string HTMLVisitor::VAL_MULTIPLE("multiple");
const std::string HTMLVisitor::VAL_SELECTED("selected");
const std::string HTMLVisitor::VAL_PASSWORD("password");
const std::string HTMLVisitor::ASSIGNQUOTE("=\"");
const std::string HTMLVisitor::QUOTE("\"");
const std::string HTMLVisitor::XML_BR("<br>");
const std::string HTMLVisitor::XML_A_OPEN("<a>");
const std::string HTMLVisitor::XML_A_CLOSE("</a>");
const std::string HTMLVisitor::XML_P_OPEN("<p>");
const std::string HTMLVisitor::XML_P_CLOSE("</p>");
const std::string HTMLVisitor::XML_TR_OPEN("<tr>");
const std::string HTMLVisitor::XML_TR_CLOSE("</tr>");
const std::string HTMLVisitor::XML_TH_OPEN("<th>");
const std::string HTMLVisitor::XML_TH_CLOSE("</th>");
const std::string HTMLVisitor::XML_TD_OPEN("<td>");
const std::string HTMLVisitor::XML_TD_CLOSE("</td>");
const std::string HTMLVisitor::ATTR_HREF("href");
const std::string HTMLVisitor::ATTR_TYPE("type");
const std::string HTMLVisitor::ATTR_VALUE("value");
const std::string HTMLVisitor::ATTR_SRC("src");
const std::string HTMLVisitor::ATTR_ID("id");
const std::string HTMLVisitor::ATTR_ONCLICK("onclick");
const std::string HTMLVisitor::ATTR_ALT("alt");
const std::string HTMLVisitor::ATTR_COLS("cols");
const std::string HTMLVisitor::ATTR_CHECKED("checked");
const std::string HTMLVisitor::ATTR_ROWS("rows");
const std::string HTMLVisitor::ATTR_SIZE("size");
const std::string HTMLVisitor::ATTR_MAXLENGTH("maxlength");
const std::string HTMLVisitor::ATTR_NAME("name");
const std::string HTMLVisitor::CLASS_BUTTON("button");
const std::string HTMLVisitor::CLASS_CHECKBOX("checkbox");
const std::string HTMLVisitor::CLASS_COMBOBOX("combobox");
const std::string HTMLVisitor::CLASS_IMAGE("image");
const std::string HTMLVisitor::CLASS_IMAGEBUTTON("imagebutton");
const std::string HTMLVisitor::CLASS_LISTVIEW("listview");
const std::string HTMLVisitor::CLASS_RADIOBUTTON("radiobutton");
const std::string HTMLVisitor::CLASS_TABLE("table");
const std::string HTMLVisitor::CLASS_TEXTAREA("textarea");
const std::string HTMLVisitor::CLASS_TEXTFIELD("textfield");
const std::string HTMLVisitor::CLASS_PASSWORD("password");
const std::string HTMLVisitor::FILE_APPINF_JS("appinf.js");
const std::string HTMLVisitor::EVENT_SINGLECLICK("onclick");
const std::string HTMLVisitor::EVENT_DOUBLECLICK("ondblclick");
const std::string HTMLVisitor::EVENT_MOUSEDOWN("onmousedown");
const std::string HTMLVisitor::EVENT_MOUSEUP("onmouseup");
const std::string HTMLVisitor::EVENT_MOUSEOUT("onmouseout");
const std::string HTMLVisitor::EVENT_MOUSEOVER("onmouseover");
const std::string HTMLVisitor::EVENT_MOUSEMOVE("onmousemove");
const std::string HTMLVisitor::EVENT_FOCUSENTER("onfocus");
const std::string HTMLVisitor::EVENT_FOCUSLOST("onblur");
const std::string HTMLVisitor::EVENT_KEYUP("onkeyup");
const std::string HTMLVisitor::EVENT_KEYDOWN("onkeydown");
const std::string HTMLVisitor::EVENT_KEYPRESSED("onkeypressed");
const std::string HTMLVisitor::EVENT_SELECT("onselect");
const std::string HTMLVisitor::EVENT_CHANGE("onchange");


HTMLVisitor::HTMLVisitor(std::ostream& out, const Poco::URI& rootAddress):
	_out(out),
	_rootAddress(rootAddress),
	_pActiveForm(0)
{
	_javaScriptIncludes.insert(FILE_APPINF_JS);
}


HTMLVisitor::~HTMLVisitor()
{
}


void HTMLVisitor::visit(Label& label)
{
	//writeOpenTag(TAG_PRE);
	_out << label.getText();
	//writeCloseTag(TAG_PRE);
}



void HTMLVisitor::visit(HTML& ht)
{
	_out << ht.getText();
}


void HTMLVisitor::visit(RootPanel& main)
{
	preVisit(main);
	writeOpenTag(TAG_HTML);
	writeOpenTag(TAG_HEAD);
	writeJavaScript();
	writeOpenTag(TAG_TITLE);
	_out << main.getName();
	writeCloseTag(TAG_TITLE);
	Poco::AutoPtr<HTML> ptrHdr = main.getHeader();
	if (ptrHdr)
		ptrHdr->accept(*this);
	writeCloseTag(TAG_HEAD);

	writeOpenTag(TAG_BODY);
	accept(main.children());
	writeCloseTag(TAG_BODY);
	writeCloseTag(TAG_HTML);
}


void HTMLVisitor::visit(Image& img)
{
	Widget::Attributes attr(img.getAttributes());
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_IMAGE));
	handleWidgetCallback(img, attr);
	if (img.getWidth()>0)
		attr.insert(std::make_pair(Image::XML_WIDTH, Poco::NumberFormatter::format(img.getWidth())));
	if (img.getHeight()>0)
		attr.insert(std::make_pair(Image::XML_HEIGHT, Poco::NumberFormatter::format(img.getHeight())));
	writeTagWithAttributes(TAG_IMG, attr);
}


void HTMLVisitor::visit(FlowPanel& flow)
{
	writeOpenWithAttributes(TAG_DIV, flow.getAttributes());
	// a flowpanel only decorates with <a></a>
	FlowPanel::Children::const_iterator it = flow.children().begin();
	FlowPanel::Children::const_iterator itEnd = flow.children().end();
	for (; it != itEnd; ++it)
	{
		_out << XML_A_OPEN;
		Poco::AutoPtr<Widget> cpy = *it;
		cpy->accept(*this);
		_out << XML_A_CLOSE;
	}
	writeCloseTag(TAG_DIV);
}


void HTMLVisitor::visit(Table& table)
{
	Widget::Attributes attr(table.getAttributes());
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_TABLE));
	handleWidgetCallback(table, attr);
	writeOpenWithAttributes(TAG_TABLE, attr);
	Table::Content content = table.getContent();
	Table::Content::const_iterator it = content.begin();
	Table::Content::const_iterator itEnd = content.end();
	if (it != itEnd)
	{
		if (table.hasHeader())
		{
			// header line
			writeOpenWithAttributes(TAG_THEAD, table.getHeaderAttributes());
			// <tr><th>...</th></tr>
			_out << XML_TR_OPEN;
			Table::Row::const_iterator itRow = it->begin();
			Table::Row::const_iterator itRowEnd = it->end();
			for (; itRow != itRowEnd; ++itRow)
			{
				_out << XML_TH_OPEN;
				Poco::AutoPtr<Widget> ptrTmp = *itRow;
				if (ptrTmp)
					ptrTmp->accept(*this);
				else
					_out << VAL_TABLECELLEMPTY;
				_out << XML_TH_CLOSE;
			}
			_out << XML_TR_CLOSE;
			writeCloseTag(TAG_THEAD);
			++it;
		}
		if (table.hasFooter())
		{
			--itEnd;
			if (itEnd != content.begin() || !table.hasHeader()) // don't write the first line again
			{
				writeOpenWithAttributes(TAG_TFOOT, table.getFooterAttributes());
				Table::Row::const_iterator itRow = itEnd->begin();
				Table::Row::const_iterator itRowEnd = itEnd->end();
				_out << XML_TR_OPEN;
				for (; itRow != itRowEnd; ++itRow)
				{
					_out << XML_TD_OPEN;
					Poco::AutoPtr<Widget> ptrTmp = *itRow;
					if (ptrTmp)
						ptrTmp->accept(*this);
					else
						_out << VAL_TABLECELLEMPTY;
					_out << XML_TD_CLOSE;
				}
				_out << XML_TR_CLOSE;
				writeCloseTag(TAG_TFOOT);
			}
		}
	}
	writeOpenWithAttributes(TAG_TBODY, table.getBodyAttributes());
	for (; it != itEnd; ++it)
	{
		_out << XML_TR_OPEN;
		Table::Row::const_iterator itRow = it->begin();
		Table::Row::const_iterator itRowEnd = it->end();
		for (; itRow != itRowEnd; ++itRow)
		{
			_out << XML_TD_OPEN;
			Poco::AutoPtr<Widget> ptrTmp = *itRow;
			if (ptrTmp)
				ptrTmp->accept(*this);
			else
				_out << VAL_TABLECELLEMPTY;
			_out << XML_TD_CLOSE;
		}
		_out << XML_TR_CLOSE;
	}
	writeCloseTag(TAG_TBODY);
	writeCloseTag(TAG_TABLE);
}


void HTMLVisitor::visit(HyperLink& link)
{
	Widget::Attributes attr(link.getAttributes());
	attr.insert (std::make_pair(ATTR_HREF, link.getURI().toString()));
	handleWidgetCallback(link, attr);
	writeOpenWithAttributes(TAG_A, attr);
	if (link.getInnerWidget())
	{
		link.getInnerWidget()->accept(*this);
	}
	_out << XML_A_CLOSE;
}


void HTMLVisitor::visit(Button& but)
{
	//<input type="submit|reset" value="Absenden">
	Widget::Attributes attr(but.getAttributes());
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_BUTTON));
	if (but.getType() == Button::TYPE_RESET)
		attr.insert(std::make_pair(ATTR_TYPE, VAL_RESET));
	else
		attr.insert(std::make_pair(ATTR_TYPE, VAL_SUBMIT));
	handleWidgetCallback(but, attr);
	attr.insert(std::make_pair(ATTR_VALUE, but.getText())); 
	writeTagWithAttributes(TAG_INPUT, attr);
}


void HTMLVisitor::visit(ImageButton& but)
{
	//<input type="image" src="absende.gif" alt="Absenden">
	Widget::Attributes attr(but.getAttributes());
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_IMAGEBUTTON));
	attr.insert(std::make_pair(ATTR_TYPE, VAL_IMAGE));
	attr.insert(std::make_pair(ATTR_SRC, but.getImage().toString()));
	attr.insert(std::make_pair(ATTR_ALT, but.getText()));
	if (but.getWidth()>0)
		attr.insert(std::make_pair(ImageButton::XML_WIDTH, Poco::NumberFormatter::format(but.getWidth())));
	if (but.getHeight()>0)
		attr.insert(std::make_pair(ImageButton::XML_HEIGHT, Poco::NumberFormatter::format(but.getHeight())));
	handleWidgetCallback(but, attr);
	writeTagWithAttributes(TAG_INPUT, attr);
}


void HTMLVisitor::visit(TextArea& txt)
{
	std::pair<Form*, InputField*> p = std::make_pair(_pActiveForm, &txt);
	EHasInputField(this, p);

	//<textarea name="Text" rows="10" cols="50">def text</textarea>
	Widget::Attributes attr(txt.getAttributes());
	handleWidgetCallback(txt, attr);
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_TEXTAREA));
	attr.insert(std::make_pair(ATTR_NAME, txt.name()));
	attr.insert(std::make_pair(ATTR_ROWS, Poco::NumberFormatter::format(txt.getRows())));
	attr.insert(std::make_pair(ATTR_COLS, Poco::NumberFormatter::format(txt.getCols())));
	writeOpenWithAttributes(TAG_TEXTAREA, attr);
	if (!txt.getText().empty())
		_out << txt.getText();
	writeCloseTag(TAG_TEXTAREA);
}


void HTMLVisitor::visit(TextField& txt)
{
	std::pair<Form*, InputField*> p = std::make_pair(_pActiveForm, &txt);
	EHasInputField(this, p);

	//<input name="Zuname" type="text" size="30" maxlength="40">
	Widget::Attributes attr(txt.getAttributes());
	handleWidgetCallback(txt, attr);
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_TEXTFIELD));
	attr.insert(std::make_pair(ATTR_NAME, txt.name()));
	attr.insert(std::make_pair(ATTR_TYPE, VAL_TEXT));
	attr.insert(std::make_pair(ATTR_SIZE, Poco::NumberFormatter::format(txt.getSize())));
	if (!txt.getText().empty())
		attr.insert(std::make_pair(ATTR_VALUE, txt.getText()));
	if (txt.getMaxLength() > 0)
	{
		attr.insert(std::make_pair(ATTR_MAXLENGTH, Poco::NumberFormatter::format(txt.getMaxLength())));
	}
	writeTagWithAttributes(TAG_INPUT, attr);
}


void HTMLVisitor::visit(CheckBox& but)
{
	std::pair<Form*, CheckBox*> p = std::make_pair(_pActiveForm, &but);
	EHasCheckBox(this, p);

	//<input type="checkbox" name="zutat" value="salami" checked="checked">
	Widget::Attributes attr(but.getAttributes());
	handleWidgetCallback(but, attr);
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_CHECKBOX));
	attr.insert(std::make_pair(ATTR_TYPE, VAL_CHECKBOX));
	attr.insert(std::make_pair(ATTR_NAME, but.name()));
	attr.insert(std::make_pair(ATTR_VALUE, but.getText()));
	if (but.getChecked())
		attr.insert(std::make_pair(ATTR_CHECKED, ATTR_CHECKED));
	writeTagWithAttributes(TAG_INPUT, attr);
	_out << but.getText();
}


void HTMLVisitor::visit(RadioButton& but)
{
	std::pair<Form*, CheckBox*> p = std::make_pair(_pActiveForm, &but);
	EHasCheckBox(this, p);

	//<input type="radio" name="zutat" value="salami">
	//<input type="radio" name="zutat" value="cheese">
	Widget::Attributes attr(but.getAttributes());
	handleWidgetCallback(but, attr);
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_RADIOBUTTON));
	attr.insert(std::make_pair(ATTR_TYPE, VAL_RADIO));
	attr.insert(std::make_pair(ATTR_NAME, but.name()));
	attr.insert(std::make_pair(ATTR_VALUE, but.getText()));
	if (but.getChecked())
		attr.insert(std::make_pair(ATTR_CHECKED, ATTR_CHECKED));
	writeTagWithAttributes(TAG_INPUT, attr);
	_out << but.getText();
}


void HTMLVisitor::visit(Form& f)
{
	_pActiveForm = &f;
	std::pair<Poco::URI, Form*> p = std::make_pair(_rootAddress, _pActiveForm);
	EContainsForm(this, p);
	//<form action="/cgi-bin/auswertung.pl" method="get" target="Daten">
	//   children
	//</form>
	Widget::Attributes attr(f.getAttributes());
	attr.insert(std::make_pair(Form::XML_ACTION, f.getAction().toString()));
	attr.insert(std::make_pair(Form::XML_METHOD, f.getMethodStr()));
	writeOpenWithAttributes(TAG_FORM, attr);
	accept(f.children());
	writeCloseTag(TAG_FORM);
}


void HTMLVisitor::visit(IndexedPanel& p)
{
	accept(p.children());
}


void HTMLVisitor::visit(StackPanel& p)
{
	writeOpenWithAttributes(TAG_DIV, p.getAttributes());
	std::vector<Poco::AutoPtr<Widget> >::const_iterator it = p.children().begin();
	std::vector<Poco::AutoPtr<Widget> >::const_iterator itEnd = p.children().end();
	for (; it != itEnd; ++it)
	{
		if (it != p.children().begin())
			_out << XML_BR;
		Poco::AutoPtr<Widget> ptr = *it;
		ptr->accept(*this);
	}
	writeCloseTag(TAG_DIV);
}


void HTMLVisitor::visit(ComboBox& p)
{
	//<select name="top5" size="1">
	Widget::Attributes attr(p.getAttributes());
	handleWidgetCallback(p, attr);
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_COMBOBOX));
	attr.insert(std::make_pair(ATTR_NAME, p.getName()));
	attr.insert(std::make_pair(ATTR_SIZE, "1"));
	writeOpenWithAttributes(TAG_SELECT, attr);
	std::vector<Poco::AutoPtr<Widget> >::const_iterator it = p.children().begin();
	std::vector<Poco::AutoPtr<Widget> >::const_iterator itEnd = p.children().end();
	int selected = p.getSelectedIndex();
	int cnt = 0;
	for (; it != itEnd; ++it, ++cnt)
	{
		Poco::AutoPtr<Widget> ptr = *it;
		Widget::Attributes optAttr;
		if (cnt == selected)
			optAttr.insert(std::make_pair(VAL_SELECTED, VAL_SELECTED));

		writeOpenWithAttributes(TAG_OPTION, optAttr);
		ptr->accept(*this);
		writeCloseTag(TAG_OPTION);
	}
	writeCloseTag(TAG_SELECT);
}


void HTMLVisitor::visit(ListView& p)
{
	//<select name="top5" size="1" multiple="multiple">
	Widget::Attributes attr(p.getAttributes());
	handleWidgetCallback(p, attr);
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_LISTVIEW));
	attr.insert(std::make_pair(ATTR_NAME, p.getName()));
	attr.insert(std::make_pair(ATTR_SIZE, Poco::NumberFormatter::format(p.getViewSize())));
	if (p.getMultiple())
		attr.insert(std::make_pair(VAL_MULTIPLE, VAL_MULTIPLE));
	writeOpenWithAttributes(TAG_SELECT, attr);
	std::vector<Poco::AutoPtr<Widget> >::const_iterator it = p.children().begin();
	std::vector<Poco::AutoPtr<Widget> >::const_iterator itEnd = p.children().end();
	std::set<int> selected = p.getSelectedIndizes();
	int cnt = 0;
	for (; it != itEnd; ++it, ++cnt)
	{
		Poco::AutoPtr<Widget> ptr = *it;
		Widget::Attributes optAttr;
		if (selected.find(cnt) != selected.end() )
		{
			optAttr.insert(std::make_pair(VAL_SELECTED, VAL_SELECTED));
			if (!p.getMultiple())
				selected.clear();
		}

		writeOpenWithAttributes(TAG_OPTION, optAttr);
		ptr->accept(*this);
		writeCloseTag(TAG_OPTION);
	}
	writeCloseTag(TAG_SELECT);
}


void HTMLVisitor::visit(HidablePanel& l)
{
	// write an Imagebutton
	Widget::Attributes attr;
	attr.insert(std::make_pair(ATTR_ID, l.getAttrID()));
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_IMAGEBUTTON));
	attr.insert(std::make_pair(ATTR_TYPE, VAL_IMAGE));
	attr.insert(std::make_pair(ATTR_SRC, l.onImg().toString()));
	attr.insert(std::make_pair(ATTR_ONCLICK, onClickMethodName(l.getAttrID())+"()"));
	writeTagWithAttributes(TAG_INPUT, attr);
	//write the text
	_out << l.text() << "<br/>";
	// write the child
	l.getWidget()->accept(*this);
}



void HTMLVisitor::visit(PwdField& txt)
{
	std::pair<Form*, InputField*> p = std::make_pair(_pActiveForm, &txt);
	EHasInputField(this, p);

	//<input name="Zuname" type="password" size="30" maxlength="40">
	Widget::Attributes attr(txt.getAttributes());
	handleWidgetCallback(txt, attr);
	attr.insert(std::make_pair(Widget::XML_CLASS, CLASS_PASSWORD));
	attr.insert(std::make_pair(ATTR_NAME, txt.name()));
	attr.insert(std::make_pair(ATTR_TYPE, VAL_PASSWORD));
	attr.insert(std::make_pair(ATTR_SIZE, Poco::NumberFormatter::format(txt.getSize())));
	// never send the stored password as ATTR_VALUE
	if (txt.getMaxLength() > 0)
	{
		attr.insert(std::make_pair(ATTR_MAXLENGTH, Poco::NumberFormatter::format(txt.getMaxLength())));
	}
	writeTagWithAttributes(TAG_INPUT, attr);
}

void HTMLVisitor::preVisit(Widget& widget)
{
	assertHasID(widget);
	handleEvent(widget, widget.ESingleClick, EVENT_SINGLECLICK);
	handleEvent(widget, widget.EDoubleClick, EVENT_DOUBLECLICK);
	handleEvent(widget, widget.EMouseDown, EVENT_MOUSEDOWN);
	handleEvent(widget, widget.EMouseUp, EVENT_MOUSEUP);
	handleEvent(widget, widget.EMouseOut, EVENT_MOUSEOUT);
	handleEvent(widget, widget.EMouseOver, EVENT_MOUSEOVER);
	handleEvent(widget, widget.EMouseOver, EVENT_MOUSEMOVE);
	handleEvent(widget, widget.EMouseOver, EVENT_FOCUSENTER);
	handleEvent(widget, widget.EMouseOver, EVENT_FOCUSLOST);
	handleEvent(widget, widget.EKeyUp, EVENT_KEYUP);
	handleEvent(widget, widget.EKeyDown, EVENT_KEYDOWN);
	handleEvent(widget, widget.EKeyPressed, EVENT_KEYPRESSED);

	std::pair<Poco::URI, Widget*> nfo = std::make_pair(_rootAddress, &widget);
	EWidget(this, nfo);
}


void HTMLVisitor::preVisit(InputField& input)
{
	assertHasID(input);
	handleEvent(input, input.ESelect, EVENT_SELECT);
	handleEvent(input, input.EChange, EVENT_CHANGE);
	preVisit(static_cast<Widget&>(input));
}


void HTMLVisitor::preVisit(SimplePanel& widget)
{
	preVisit(static_cast<Widget&>(widget));
	widget.getWidget()->preAccept(*this);
}


void HTMLVisitor::preVisit(IndexedPanel& widget)
{
	preVisit(static_cast<Widget&>(widget));
	preAccept(widget.children());
}


void HTMLVisitor::preVisit(RootPanel& main)
{
	preVisit(static_cast<Widget&>(main));
	_javaScriptHeader.clear();
	_javaScriptOnLoad.clear();
	preAccept(main.children());
}


void HTMLVisitor::preVisit(HidablePanel& widget)
{
	//a HidablePanel must have an id, also its child
	preVisit(static_cast<Widget&>(widget));

	if (widget.getWidget()->getAttrID().empty())
		widget.getWidget()->setAttrID(autoID());
	std::string fctName = onClickMethodName(widget.getAttrID());

	addJavaScript("function "+fctName+"() {");
		addJavaScript("var child = $(\""+widget.getWidget()->getAttrID()+"\");");
		addJavaScript("var imgBut = $(\""+widget.getAttrID()+"\");");
		addJavaScript("if (child.style.display == \"none\") {");
		if(widget.inlineMode())
			addJavaScript("child.style.display = \"inline\";");
		else
			addJavaScript("child.style.display = \"block\";");
			addJavaScript("imgBut.src = \"" + widget.onImg().toString() + "\";");
		addJavaScript("} else {");
			addJavaScript("child.style.display = \"none\";");
			addJavaScript("imgBut.src = \"" + widget.offImg().toString() + "\";");
		addJavaScript("}");
	addJavaScript("}");
	widget.getWidget()->preAccept(*this);
}


void HTMLVisitor::writeOpenWithAttributes(const std::string& tag, const Widget::Attributes& attr)
{
	_out << PRE_OPEN << tag;
	writeAttributes(attr);
	_out << CLOSE;
}


void HTMLVisitor::writeTagWithAttributes(const std::string& tag, const Widget::Attributes& attr)
{
	_out << PRE_OPEN << tag;
	writeAttributes(attr);
	_out << FULLCLOSE;
}


void HTMLVisitor::writeAttributes(const Widget::Attributes& attr)
{
	Widget::Attributes::const_iterator it = attr.begin();
	Widget::Attributes::const_iterator itEnd = attr.end();
	for (; it != itEnd; ++it)
	{
		_out << VAL_SPACE << it->first << ASSIGNQUOTE << it->second << QUOTE;
	}
}


void HTMLVisitor::accept(const std::vector<Poco::AutoPtr<Widget> >& widgets)
{
	std::vector<Poco::AutoPtr<Widget> >::const_iterator it = widgets.begin();
	std::vector<Poco::AutoPtr<Widget> >::const_iterator itEnd = widgets.end();
	for (; it != itEnd; ++it)
	{
		Poco::AutoPtr<Widget> ptr = *it;
		ptr->accept(*this);
	}
}


void HTMLVisitor::preAccept(const std::vector<Poco::AutoPtr<Widget> >& widgets)
{
	std::vector<Poco::AutoPtr<Widget> >::const_iterator it = widgets.begin();
	std::vector<Poco::AutoPtr<Widget> >::const_iterator itEnd = widgets.end();
	for (; it != itEnd; ++it)
	{
		Poco::AutoPtr<Widget> ptr = *it;
		ptr->preAccept(*this);
	}
}


std::string HTMLVisitor::autoID()
{
	static Poco::UInt32 VAL_ID(0);
	static const std::string STR_ID("id");
	std::string res(STR_ID);
	res.append(Poco::NumberFormatter::format(VAL_ID++));
	return res;
}


void HTMLVisitor::writeJavaScript()
{
	int ind = 0;
	writeJSIncludes(0);

	if (_javaScriptHeader.empty() && _javaScriptOnLoad.empty())
		return;

	writeSingleLine("<script type=\"text/javascript\">", ind);

	std::list<std::string>::const_iterator it = _javaScriptHeader.begin();
	std::list<std::string>::const_iterator itEnd = _javaScriptHeader.end();
	for (; it != itEnd; ++it)
	{
		writeSingleLine(*it, ind);
	}


	if (!_javaScriptOnLoad.empty())
	{
		writeSingleLine("window.onLoad = function() {", ind);

		it = _javaScriptOnLoad.begin();
		itEnd = _javaScriptOnLoad.end();
		for (; it != itEnd; ++it)
		{
			writeSingleLine(*it, ind);
		}

		writeSingleLine("}", ind);
	}

	writeSingleLine("</script>", ind);

	_javaScriptHeader.clear();
	_javaScriptOnLoad.clear();
}


void HTMLVisitor::writeSingleLine(const std::string& code, int& indentation)
{
	int cntOpen = (int)std::count_if(code.begin(), code.end(), std::bind2nd(std::equal_to<char>(), '{'));
	int cntClose = (int)std::count_if(code.begin(), code.end(), std::bind2nd(std::equal_to<char>(), '}'));
	if (!code.empty() && code[0] == '}')
		writeIndent(indentation-1);
	else
		writeIndent(indentation);

	_out << code << std::endl;
	indentation += (cntOpen-cntClose);
	if (indentation<0)
		indentation = 0;
}


void HTMLVisitor::writeIndent(int indent)
{
	static const std::string ind[] = {"", "\t", "\t\t", "\t\t\t", "\t\t\t\t", "\t\t\t\t\t", "\t\t\t\t\t\t"};
	if (indent > 6)
		indent  = 6;
	if (indent < 0)
		indent = 0;
	_out << ind[indent];
}


void HTMLVisitor::writeJSIncludes(int indent)
{
	std::set<std::string>::const_iterator it = _javaScriptIncludes.begin();
	std::set<std::string>::const_iterator itEnd = _javaScriptIncludes.end();
	for (; it != itEnd; ++it)
	{
		if (!it->empty())
		{
			//<script src="xxx.js"></script>
			std::string line=("<script src=\"");
			line.append(*it);
			line.append("\"></script>");
			writeSingleLine(line, indent);
		}
	}
}


void HTMLVisitor::handleWidgetCallback(Widget& widget, Widget::Attributes& attr)
{
	handleCallbackGeneration(widget, widget.ESingleClick, EVENT_SINGLECLICK, attr);
	handleCallbackGeneration(widget, widget.EDoubleClick, EVENT_DOUBLECLICK, attr);
	handleCallbackGeneration(widget, widget.EMouseDown, EVENT_MOUSEDOWN, attr);
	handleCallbackGeneration(widget, widget.EMouseUp, EVENT_MOUSEUP, attr);
	handleCallbackGeneration(widget, widget.EMouseOver, EVENT_MOUSEOVER, attr);
	handleCallbackGeneration(widget, widget.EMouseOut, EVENT_MOUSEOUT, attr);
	handleCallbackGeneration(widget, widget.EMouseMove, EVENT_MOUSEMOVE, attr);
	handleCallbackGeneration(widget, widget.EFocusEnter, EVENT_FOCUSENTER, attr);
	handleCallbackGeneration(widget, widget.EFocusLost, EVENT_FOCUSLOST, attr);
	handleCallbackGeneration(widget, widget.EKeyUp, EVENT_KEYUP, attr);
	handleCallbackGeneration(widget, widget.EKeyDown, EVENT_KEYDOWN, attr);
	handleCallbackGeneration(widget, widget.EKeyPressed, EVENT_KEYPRESSED, attr);
	InputField* pIn = dynamic_cast<InputField*>(&widget);
	if (pIn)
	{
		handleCallbackGeneration(widget, pIn->ESelect, EVENT_SELECT, attr);
		handleCallbackGeneration(widget, pIn->EChange, EVENT_CHANGE, attr);
	}
}


std::string HTMLVisitor::generateMultiEventHandlerName(const Widget& widget, const std::string& eventType)
{
	static const std::string PRE("multiEventHandler");
	return PRE + eventType + widget.getAttrID();
}


std::string HTMLVisitor::generateServerEventHandlerName(const Widget& widget)
{
	static const std::string PRE("serverEventHandler");
	return PRE + widget.getAttrID();
}


} } // namespace Poco::WebWidgets
