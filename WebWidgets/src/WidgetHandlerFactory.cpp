//
// WidgetHandlerFactory.cpp
//
// $Id: //poco/Main/WebWidgets/src/WidgetHandlerFactory.cpp#4 $
//
// Library: WebWidgets
// Package: HTTPHandler
// Module:  WidgetHandlerFactory
//
// Copyright (c) 2007, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/WebWidgets/WidgetHandlerFactory.h"
#include "Poco/WebWidgets/WidgetHandler.h"
#include "Poco/WebWidgets/JSEventHandler.h"
#include "Poco/WebWidgets/FileHandler.h"
#include "Poco/WebWidgets/FormHandler.h"
#include "Poco/WebWidgets/HTMLVisitor.h"
#include "Poco/Delegate.h"
#include "Poco/NullStream.h"


namespace Poco {
namespace WebWidgets {


WidgetHandlerFactory::WidgetHandlerFactory()
{
}


WidgetHandlerFactory::~WidgetHandlerFactory()
{
}



void WidgetHandlerFactory::addWidget(const Poco::URI& path, Poco::AutoPtr<Widget> ptr)
{
	poco_check_ptr (ptr.get());
	_widgets.insert(std::make_pair(path.toString(), ptr));

	//Note: we always call visit once so that form and input data are initialized
	// otherwise a cached client gui could trigger errors
	Poco::NullOutputStream nos;
	HTMLVisitor visitor(nos, path);
	visitor.EContainsForm += delegate(this, &WidgetHandlerFactory::onContainsForm);
	visitor.EHasInputField+= delegate(this, &WidgetHandlerFactory::onHasInputField);
	visitor.EHasCheckBox  += delegate(this, &WidgetHandlerFactory::onHasCheckBox);
	ptr->accept(visitor);
	
}


void WidgetHandlerFactory::removeWidget(const Poco::URI& path)
{
	std::string uri = path.toString();
	_widgets.erase(uri);
	// remove forms+actions
	_forms.erase(uri);
	Forms::iterator itBeg = _forms.lower_bound(uri);
	Forms::iterator itEnd = _forms.upper_bound(uri);
	for (; itBeg != itEnd && itBeg != _forms.end(); ++itBeg)
	{
		_actions.erase(itBeg->first);
	}
}


void WidgetHandlerFactory::registerForm(const Poco::URI& owner, Poco::AutoPtr<Form> ptrForm)
{
	poco_check_ptr (ptrForm.get());
	const std::string& action = ptrForm->getAction().toString();
	std::string uri(owner.toString());
	if (_widgets.find(uri) == _widgets.end())
		throw Poco::NotFoundException("Failed to find owner widget of the form");
	poco_assert (_widgets.find(action) == _widgets.end());
	_forms.insert(std::make_pair(uri, ptrForm));
	_actions.insert(std::make_pair(action, ptrForm));
	_inputs.insert(std::make_pair(action, NamedInputFields()));
	_checkBoxes.insert(std::make_pair(action, NamedCheckBoxes()));
}


std::set<std::string> WidgetHandlerFactory::getHandledURIs() const
{
	std::set<std::string> result;
	Widgets::const_iterator it = _widgets.begin();
	Widgets::const_iterator itEnd = _widgets.end();
	for (; it != itEnd; ++it)
		result.insert(it->first);
	return result;
}


Poco::Net::HTTPRequestHandler* WidgetHandlerFactory::createRequestHandler(const Poco::Net::HTTPServerRequest& request)
{
	std::string uri = Poco::URI(request.getURI()).getPath();

	std::size_t pos = uri.find("/events");
	if (pos != std::string::npos)
	{
		uri = uri.substr(0, pos);
		if (uri.empty())
			uri = "/";
		OwnerToWidgets::iterator it = _allWidgets.find(uri);
		if (it == _allWidgets.end())
			throw Poco::NotFoundException("No event handler at address " + uri);
		JSEventHandler* pEH = new JSEventHandler(it->second);
		return pEH;
	}
	else
	{
		Widgets::iterator it = _widgets.find(uri);
		if (it != _widgets.end())
		{
			WidgetHandler* pWH = new WidgetHandler(it->second);
			pWH->EWidget       += delegate(this, &WidgetHandlerFactory::onWidget);
			pWH->EContainsForm += delegate(this, &WidgetHandlerFactory::onContainsForm);
			pWH->EHasInputField+= delegate(this, &WidgetHandlerFactory::onHasInputField);
			pWH->EHasCheckBox  += delegate(this, &WidgetHandlerFactory::onHasCheckBox);
			return pWH;
		}
		else
		{
			Actions::iterator itA = _actions.find(uri);
			ActionInputs::iterator itI = _inputs.find(uri);
			ActionCheckBoxes::iterator itC = _checkBoxes.find(uri);
			if (itA != _actions.end() && itI != _inputs.end() && itC != _checkBoxes.end())
				return new FormHandler(itA->second, itI->second, itC->second);
		}
		
	}

	return new FileHandler();
}


void WidgetHandlerFactory::onContainsForm(std::pair<Poco::URI, Form*>& aPair)
{
	registerForm(aPair.first, Poco::AutoPtr<Form>(aPair.second, true));
}


void WidgetHandlerFactory::onHasInputField(std::pair<Form*, InputField*>& aPair)
{
	if (!aPair.first) // an inputfield without a form is a NOOP
		return;
	registerInputField(aPair.first->getAction().toString(), Poco::AutoPtr<InputField>(aPair.second, true));
}


void WidgetHandlerFactory::onHasCheckBox(std::pair<Form*, CheckBox*>& aPair)
{
	if (!aPair.first) // an inputfield without a form is a NOOP
		return;

	registerCheckBox(aPair.first->getAction().toString(), Poco::AutoPtr<CheckBox>(aPair.second, true));
}


void WidgetHandlerFactory::onWidget(std::pair<Poco::URI, Widget*>& aPair)
{
	OwnerToWidgets::iterator it = _allWidgets.insert(std::make_pair(aPair.first.toString(), IDToWidget())).first;
	IDToWidget& widgets = it->second;
	std::pair<IDToWidget::iterator, bool> ret = widgets.insert(std::make_pair(aPair.second->getAttrID(), aPair.second));
	if (!ret.second)
		ret.first->second = aPair.second;
}


void WidgetHandlerFactory::registerInputField(const std::string& uri, Poco::AutoPtr<InputField> ptrInput)
{
	ActionInputs::iterator it = _inputs.find(uri);
	poco_assert (it != _inputs.end());
	it->second.insert(std::make_pair(ptrInput->name(), ptrInput));
}


void WidgetHandlerFactory::registerCheckBox(const std::string& uri, Poco::AutoPtr<CheckBox> ptrInput)
{
	ActionCheckBoxes::iterator it = _checkBoxes.find(uri);
	poco_assert (it != _checkBoxes.end());
	NamedCheckBoxes::iterator itN = it->second.lower_bound(ptrInput->name());
	NamedCheckBoxes::iterator itNEnd = it->second.upper_bound(ptrInput->name());
	bool found = false;
	for (; !found && itN != it->second.end() && itN != itNEnd; ++itN)
	{
		if (itN->second->getText() == ptrInput->getText())
		{
			itN->second = ptrInput;
			found = true;
		}
	}
	if (!found)
		it->second.insert(std::make_pair(ptrInput->name(), ptrInput));
}


} } // namespace Poco::WebWidgets
