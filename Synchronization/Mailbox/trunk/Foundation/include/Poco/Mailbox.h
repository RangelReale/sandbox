//
// Mailbox.h
//
// $Id: //poco/1.3/Foundation/include/Poco/Mailbox.h#2 $
//
// Library: Foundation
// Package: Threading
// Module:  Mailbox
//
// Definition of the Mailbox class.
//
// Copyright (c) 2004-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#ifndef Foundation_Mailbox_INCLUDED
#define Foundation_Mailbox_INCLUDED

#include "Poco/Foundation.h"
#include "Poco/Exception.h"
#include "Poco/Condition.h"
#include "Poco/ScopedLock.h"

#include <deque>

namespace Poco {

template <class T, class M>
class Mailbox
	/// A Mailbox is a fixed-size queue implementation for thread synchronization
	/// and messaging. Using post() method to put a message to a mailbox and 
	/// pend() method can be used to fetch a message from it. Thread will block
	/// for following cases:
	///  1. Calling post() method when the mailbox is full.
	///  2. Calling pend() method when the mailbox is empty.
	/// Block period can be specified by means of timeout parameter. 
	///
	/// The differences between Mailbox and NotificationQueue are:
	///  1. For Mailbox, message will be copied by value during dispatching
	///  2. The maximal capacity of the Mailbox is fixed.
	///  3. Mailbox's message does not have priority.
	///  4. The type for Mailbox message should be copyable and default constructible
	///
{

public:

	Mailbox(long length) : _isReset(false), _length(length)
		/// Create Mailbox object
	{
	}

	virtual ~Mailbox()
		/// Destroy Mailbox object
	{
		try{
			_queue.clear();
		}
		catch(...){}
	}

	bool post(T msg) 
		/// Post the given message by adding it to the end of the queue (FIFO).
		/// Note the message is copied by value.
	{
		Poco::ScopedLock<M> lock(_mutex);

		// free slot query
		while((_queue.size() == _length) && !_isReset){
			_freeSlot.wait(_mutex);
		}

		// Allow no further additions in the reset state
		if(_isReset)
			throw Poco::NoPermissionException();

		_queue.push_back(msg);
		_poster.signal(); // Wake one waiter

		return true;
	}

	bool tryPost(T msg, long milliseconds) 
		/// Post the given message by adding it to the end of the queue (FIFO).
		/// Note the message is copied by value.
		/// If message can not be 
	{
		try
		{
			Poco::ScopedLock<M> lock(_mutex, milliseconds);

			// free slot query
			while((_queue.size() == _length) && !_isReset){
				_freeSlot.wait(_mutex, milliseconds);
			}

			if(_isReset)
				throw Poco::NoPermissionException();

			_queue.push_back(msg);
			_poster.signal();
		}
		catch(Poco::TimeoutException&)
		{
			return false; 
		}

		return true;    
	}

	T pend()
		/// Fetch a message if the mailbox is not empty, otherwise block till
		/// message comes or the mailbox is reset.
	{
		Poco::ScopedLock<M> lock(_mutex);

		while (_queue.size() == 0 && !_isReset) 
			_poster.wait(_mutex);

		if(_queue.size() == 0) // Queue reset
			throw Poco::NoPermissionException();

		T msg = _queue.front();
		_queue.pop_front();

		_freeSlot.signal();

		return msg;
	}

	bool tryPend(T& msg, long milliseconds)
		/// Fetch a message if the mailbox is not empty, otherwise block for specified
		/// time period till message comes or the mailbox is reset.
		/// Return false if timeout.
	{
		try
		{
			Poco::ScopedLock<M> lock(_mutex, milliseconds);

			while(_queue.size() == 0 && !_isReset) {
				if(!_poster.wait(_mutex, milliseconds))
					throw Poco::TimeoutException();
			}

			if( _queue.size() == 0) // Queue canceled
				throw Poco::NoPermissionException();

			msg = _queue.front();
			_queue.pop_front();

			_freeSlot.signal();
		}
		catch(Poco::TimeoutException&)
		{
			return false;
		}

		return true;
	}


	T tryPend(long milliseconds)
		/// Fetch a message if the mailbox is not empty, otherwise block for specified
		/// time period till message comes or the mailbox is reset. 
		/// Throw Poco::TimeoutException if timeout.
	{
		Poco::ScopedLock<M> lock(_mutex, milliseconds);

		while(_queue.size() == 0 && !_isReset) {
			if(!_poster.wait(_mutex, milliseconds))
				throw Poco::TimeoutException();
		}

		if( _queue.size() == 0) // Queue canceled
			throw Poco::NoPermissionException();

		T msg = _queue.front();
		_queue.pop_front();

		_freeSlot.signal();

		return msg;
	}

	void reset() 
		/// awake all thread pending on the mailbox, and set the mailbox to
		/// reset. 
	{
		Poco::ScopedLock<M> lock(_mutex);

		_isReset = true;
		_poster.broadcast();
	}

	bool isReset()
		/// Reset state query. 
	{
		// Faster check
		if(_isReset)
			return true;

		Poco::ScopedLock<M> lock(_mutex);

		return _isReset;
	}

	size_t size()
		/// Message count query. 
	{
		Poco::ScopedLock<M> lock(_mutex);
		return _queue.size();
	}
	
	size_t size(long milliseconds)
		/// Message count query with timeout
	{
		Poco::ScopedLock<M> lock(_mutex, milliseconds);
		return _queue.size();
	}

	bool empty() 
		/// Empty query.
	{
		Poco::ScopedLock<M> lock(_mutex);
		return _queue.empty();
	}

	bool empty(long millseconds) 
		/// Empty query with timeout.
	{
		Poco::ScopedLock<M> lock(_mutex, millseconds);
		return _queue.empty();
	}

	long length() const
	{
		return _length;
	}


private:

	M _mutex;

	Poco::Condition _freeSlot;
	Poco::Condition _poster;

	const long		_length;
	volatile bool	_isReset;
	std::deque<T>	_queue;

};

}	// namespace Poco

#endif // Foundation_Mailbox_INCLUDED

