//
// CyclicBarrier.h
//
// $Id: //poco/1.3/Foundation/include/Poco/CyclicBarrier.h#2 $
//
// Library: Foundation
// Package: Threading
// Module:  CyclicBarrier
//
// Definition of the CyclicBarrier class.
//
// Copyright (c) 2004-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#ifndef Foundation_CyclicBarrier_INCLUDED
#define Foundation_CyclicBarrier_INCLUDED


#include "Poco/Foundation.h"
#include "Poco/Exception.h"
#include "Poco/Condition.h"
#include "Poco/ScopedLock.h"

namespace Poco {

template<class M>
class Foundation_API CyclicBarrier
	/// A CyclicBarrier is a synchronization object that allows a set of 
    /// threads to all wait for each other to reach a common barrier point. 
    /// CyclicBarriers are useful in programs involving a fixed sized party
    /// of threads that must occasionally wait for each other. 
    /// The barrier is called cyclic because it can be re-used after the 
    /// waiting threads are released.
    ///
    /// A CyclicBarrier supports an optional Runnable command that is 
    /// run once per barrier point, after the last thread in the party 
    /// arrives, but before any threads are released. This barrier action
    /// is useful for updating shared-state before any of the parties continue. 
{
public:
		
    CyclicBarrier(int parties) 
        : _broken(false), _count(parties), _initCount(parties), 
		  _pBarrierAction(0)
        /// Creates a new CyclicBarrier that will trip when the given number 
        /// of parties (threads) are waiting upon it, and does not perform 
        /// a predefined action upon each barrier.
        ///
        /// Parameters:
        ///   parties - the number of threads that must invoke wait() 
        ///             before the barrier is tripped.
        /// Throws:
        ///   Poco::InvalidArgumentException - if parties is less than 1.
    {}

    CyclicBarrier(int parties, Poco::Runnable* barrierAction)
        : _broken(false), _count(parties), _initCount(parties), 
          _pBarrierAction(barrierAction)
        /// Creates a new CyclicBarrier that will trip when the given number 
        /// of parties (threads) are waiting upon it, and which will execute
        /// the given barrier action when the barrier is tripped, performed
        /// by the last thread entering the barrier.
        ///
        /// Parameters:
        ///   parties - the number of threads that must invoke wait() 
        ///             before the barrier is tripped.
        ///   barrierAction - the command to execute when the barrier is 
        ///             tripped, or null if there is no action. 
        /// Throws:
        ///   Poco::InvalidArgumentException - if parties is less than 1.
    {}
        
	~CyclicBarrier()
		/// Destroys the CyclicBarrier.
    {
    }

    int getParties() const
        /// Returns the number of parties required to trip this barrier.
    {
		return _initCount;
    }
        
    void wait()
        /// Waits until all parties have invoked wait on this barrier.
        /// If the current thread is not the last to arrive then it is 
        /// disabled for thread scheduling purposes and lies dormant 
        /// until one of following things happens:
        ///     * The last thread arrives; or
        ///     * Some other thread times out while waiting for barrier; or
        ///     * Some other thread invokes reset() on this barrier. 
        ///
        /// If the barrier is reset() while any thread is waiting, or if 
        /// the barrier is broken when wait is invoked, or while any thread 
        /// is waiting, then IllegalStateException is thrown.
        /// 
        /// If the current thread is the last thread to arrive, and a 
        /// non-null barrier action was supplied in the constructor, then the 
        /// current thread runs the action before allowing the other threads 
        /// to continue. If an exception occurs during the barrier action then 
        /// that exception will be propagated in the current thread and the 
        /// barrier is placed in the broken state.
        ///
        /// Returns:
        ///     The arrival index of the current thread, where index getParties() - 1 
        ///     indicates the first to arrive and zero indicates the last to arrive. 
        /// Throws:
        ///     IllegalStateException - if another thread was timeout while the 
        ///         current thread was waiting, or the barrier was reset, or the barrier 
        ///         was broken when wait was called, or the barrier action (if present) 
        ///         failed due an exception.
    {
		Poco::ScopedLock<M> lock(_mutex);

		if(_broken) 
			throw Poco::IllegalStateException("BrokenBarrier_Exception");

        if(--_count == 0)
		{
            // Wake the other threads if this was the last  
            // arriving thread
            _notifier.broadcast();

            // Try to run the associated task, if it throws then 
            // break the barrier and propagate the exception
            try
            {
                if(_pBarrierAction)
				{
					Poco::Thread thread;
					thread.start(*_pBarrierAction);
					thread.join();
				}

				_broken = false;        
				_count = _initCount;
            }
            catch(...)
            {
                _broken = true;
				_count = _initCount;
                throw;
            }
        }else
        {
            try 
            {
                // Wait for the other threads to arrive
                _notifier.wait(_mutex);

            } 
            catch(...)
            {
                // Break the barrier and propagate the exception
                _broken = true;
                throw;
            }

            // If the thread woke because it was notified by the thread
            // that broke the barrier, throw.
            if(_broken) 
                throw Poco::IllegalStateException("CyclicBarrier: BrokenBarrier");

        } 
    }

    void wait(long millisecond)
        /// Same as wait(), but if the specified waiting time elapses then TimeoutException  
        /// is thrown. If the time is less than or equal to zero, the method will not wait,
        /// and thow InvalidArgumentException.
    {
		Poco::ScopedLock<M> lock(_mutex);

		if(_broken) 
			throw Poco::IllegalStateException("Barrier: BrokenBarrierException");

		if(millisecond<1)
			throw Poco::IllegalStateException("Barrier: InvalidArgumentException");
			
        if(--_count == 0)
		{
            // Wake the other threads if this was the last  
            // arriving thread
            _notifier.broadcast();

            // Try to run the associated task, if it throws then 
            // break the barrier and propagate the exception
            try
            {
                if(_pBarrierAction)
				{
					Poco::Thread thread;
					thread.start(*_pBarrierAction);
					thread.join();
				}
				_broken = false;        
				_count = _initCount;
            }
            catch(...)
            {
                _broken = true;
				_count = _initCount;
                throw;
            }
        }else
        {
            try 
            {
                // Wait for the other threads to arrive
                if(!_notifier.tryWait(_mutex, millisecond)){
                    _broken = true;
                }
            } 
            catch(...)
            {
                // Break the barrier and propagate the exception
                _broken = true;
                throw;
            }

            // If the thread woke because it was notified by the thread
            // that broke the barrier, throw.
            if(_broken) 
                throw Poco::IllegalStateException("Barrier: BrokenBarrier_Exception");

        } 
    }

    bool isBroken() const
        /// Queries if this barrier is in a broken state.
        /// Returns:
        ///     true if one or more parties broke out of this barrier due to interruption 
        ///     or timeout since construction or the last reset, or a barrier action 
        ///     failed due to an exception; and false otherwise.
    {
        return _broken;
    }

    void reset()
        /// Resets the barrier to its initial state. If any parties are currently waiting 
        /// at the barrier, they will return with a BrokenBarrierException. Note that 
        /// resets after a breakage has occurred for other reasons can be complicated 
        /// to carry out; threads need to re-synchronize in some other way, and choose 
        /// one to perform the reset. It may be preferable to instead create a new barrier
        /// for subsequent use. 
    {
        Poco::ScopedLock<M> lock(_mutex);   

        _notifier.broadcast();
        _broken = false;        
        _count = _initCount;
    }

    int getNumberWaiting() const
        /// Returns the number of parties currently waiting at the barrier. 
        /// This method is primarily useful for debugging and assertions.
        /// Returns:
        ///     the number of parties currently blocked in wait()
    {
        return _initCount-_count;
    }

private:
	CyclicBarrier(const CyclicBarrier&);
	CyclicBarrier& operator = (const CyclicBarrier&);

    bool    _broken;
    int     _count;
    int     _initCount;

    M				_mutex;
    Runnable*		_pBarrierAction;
    Poco::Condition	_notifier;

};

} // namespace Poco

#endif // Foundation_CyclicBarrier_INCLUDED

