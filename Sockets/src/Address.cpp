//
// Address.cpp
//
// $Id: //poco/svn/Net/src/Address.cpp#3 $
//
// Library: Net
// Package: NetCore
// Module:  Address
//
// Copyright (c) 2005-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Sockets/Address.h"
#include "Poco/Sockets/SocketException.h"
#include "Poco/RefCountedObject.h"
#include "Poco/NumberFormatter.h"
#include "Poco/Types.h"
#include <algorithm>
#include <cctype>
#include <cstring>

	
using Poco::RefCountedObject;
using Poco::NumberFormatter;
using Poco::UInt8;
using Poco::UInt16;
using Poco::UInt32;


namespace Poco {
namespace Sockets {


//
// AddressImpl
//


class AddressImpl: public RefCountedObject
{
public:
	virtual std::string toString() const = 0;
	virtual poco_socklen_t length() const = 0;
	virtual const void* addr() const = 0;
	virtual Address::Family family() const = 0;
	virtual int af() const = 0;
	virtual bool isWildcard() const	= 0;
	virtual bool isBroadcast() const = 0;
	virtual bool isLoopback() const = 0;
	virtual bool isMulticast() const = 0;
	virtual bool isLinkLocal() const = 0;
	virtual bool isSiteLocal() const = 0;
	virtual bool isIPv4Mapped() const = 0;
	virtual bool isIPv4Compatible() const = 0;
	virtual bool isWellKnownMC() const = 0;
	virtual bool isNodeLocalMC() const = 0;
	virtual bool isLinkLocalMC() const = 0;
	virtual bool isSiteLocalMC() const = 0;
	virtual bool isOrgLocalMC() const = 0;
	virtual bool isGlobalMC() const = 0;
	virtual void mask(const AddressImpl* pMask, const AddressImpl* pSet) = 0;
	virtual AddressImpl* clone() const = 0;

protected:
	AddressImpl()
	{
	}
	
	virtual ~AddressImpl()
	{
	}

private:
	AddressImpl(const AddressImpl&);
	AddressImpl& operator = (const AddressImpl&);
};


class IPv4AddressImpl: public AddressImpl
{
public:
	IPv4AddressImpl()
	{
		std::memset(&_addr, 0, sizeof(_addr));
	}
	
	IPv4AddressImpl(const void* addr)
	{
		std::memcpy(&_addr, addr, sizeof(_addr));
	}
	
	std::string toString() const
	{
		const UInt8* bytes = reinterpret_cast<const UInt8*>(&_addr);
		std::string result;
		result.reserve(16);
		result.append(NumberFormatter::format(bytes[0]));
		result.append(".");
		result.append(NumberFormatter::format(bytes[1]));
		result.append(".");
		result.append(NumberFormatter::format(bytes[2]));
		result.append(".");
		result.append(NumberFormatter::format(bytes[3]));
		return result;
	}

	poco_socklen_t length() const
	{
		return sizeof(_addr);
	}
	
	const void* addr() const
	{
		return &_addr;
	}
	
	Address::Family family() const
	{
		return Address::IPv4;
	}
	
	int af() const
	{
		return AF_INET;
	}
	
	bool isWildcard() const
	{
		return _addr.s_addr == INADDR_ANY;
	}
	
	bool isBroadcast() const
	{
		return _addr.s_addr == INADDR_NONE;
	}
	
	bool isLoopback() const
	{
		return ntohl(_addr.s_addr) == 0x7F000001; // 127.0.0.1
	}
	
	bool isMulticast() const
	{
		return (ntohl(_addr.s_addr) & 0xF0000000) == 0xE0000000; // 224.0.0.0/24 to 239.0.0.0/24
	}
		
	bool isLinkLocal() const
	{
		return (ntohl(_addr.s_addr) & 0xFFFF0000) == 0xA9FE0000; // 169.254.0.0/16
	}
	
	bool isSiteLocal() const
	{
		UInt32 addr = ntohl(_addr.s_addr);
		return (addr & 0xFF000000) == 0x0A000000 ||      // 10.0.0.0/24
		       (addr & 0xFFFF0000) == 0xC0A80000 ||      // 192.68.0.0/16
		       addr >= 0xAC100000 && addr <= 0xAC1FFFFF; // 172.16.0.0 to 172.31.255.255
	}
	
	bool isIPv4Compatible() const
	{
		return true;
	}

	bool isIPv4Mapped() const
	{
		return true;
	}

	bool isWellKnownMC() const
	{
		return (ntohl(_addr.s_addr) & 0xFFFFFF00) == 0xE0000000; // 224.0.0.0/8
	}
	
	bool isNodeLocalMC() const
	{
		return false;
	}
	
	bool isLinkLocalMC() const
	{
		return (ntohl(_addr.s_addr) & 0xFF000000) == 0xE0000000; // 244.0.0.0/24
	}
	
	bool isSiteLocalMC() const
	{
		return (ntohl(_addr.s_addr) & 0xFFFF0000) == 0xEFFF0000; // 239.255.0.0/16
	}
	
	bool isOrgLocalMC() const
	{
		return (ntohl(_addr.s_addr) & 0xFFFF0000) == 0xEFC00000; // 239.192.0.0/16
	}
	
	bool isGlobalMC() const
	{
		UInt32 addr = ntohl(_addr.s_addr);
		return addr >= 0xE0000100 && addr <= 0xEE000000; // 224.0.1.0 to 238.255.255.255
	}

	static IPv4AddressImpl* parse(const std::string& addr)
	{
		if (addr.empty()) return 0;		
#if defined(_WIN32) 
		struct in_addr ia;
		ia.s_addr = inet_addr(addr.c_str());
		if (ia.s_addr == INADDR_NONE && addr != "255.255.255.255")
			return 0;
		else
			return new IPv4AddressImpl(&ia);
#else
#if __GNUC__ < 3
		struct in_addr ia;
		ia.s_addr = inet_addr(addr.c_str());
		if (ia.s_addr == INADDR_NONE && addr != "255.255.255.255")
			return 0;
		else
			return new IPv4AddressImpl(&ia);
#else
		struct in_addr ia;
		if (inet_aton(addr.c_str(), &ia))
			return new IPv4AddressImpl(&ia);
		else
			return 0;
#endif
#endif
	}
	
	void mask(const AddressImpl* pMask, const AddressImpl* pSet)
	{
		poco_assert (pMask->af() == AF_INET && pSet->af() == AF_INET);
		
		_addr.s_addr &= static_cast<const IPv4AddressImpl*>(pMask)->_addr.s_addr;
		_addr.s_addr |= static_cast<const IPv4AddressImpl*>(pSet)->_addr.s_addr & ~static_cast<const IPv4AddressImpl*>(pMask)->_addr.s_addr;
	}
	
	AddressImpl* clone() const
	{
		return new IPv4AddressImpl(&_addr);
	}
		
private:
	struct in_addr _addr;	
};


#if defined(POCO_HAVE_IPv6)


class IPv6AddressImpl: public AddressImpl
{
public:
	IPv6AddressImpl()
	{
		std::memset(&_addr, 0, sizeof(_addr));
	}

	IPv6AddressImpl(const void* addr)
	{
		std::memcpy(&_addr, addr, sizeof(_addr));
	}

	std::string toString() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		if (isIPv4Compatible() || isIPv4Mapped())
		{
			std::string result;
			result.reserve(24);
			if (words[5] == 0)
				result.append("::");
			else
				result.append("::FFFF:");
			const UInt8* bytes = reinterpret_cast<const UInt8*>(&_addr);
			result.append(NumberFormatter::format(bytes[12]));
			result.append(".");
			result.append(NumberFormatter::format(bytes[13]));
			result.append(".");
			result.append(NumberFormatter::format(bytes[14]));
			result.append(".");
			result.append(NumberFormatter::format(bytes[15]));
			return result;
		}
		else
		{
			std::string result;
			result.reserve(46);
			bool zeroSequence = false;
			int i = 0;
			while (i < 8)
			{
				if (!zeroSequence && words[i] == 0)
				{
					int zi = i;
					while (zi < 8 && words[zi] == 0) ++zi;
					if (zi > i + 1)
					{
						i = zi;
						result.append(":");
						zeroSequence = true;
					}
				}
				if (i > 0) result.append(":");
				if (i < 8) result.append(NumberFormatter::formatHex(ntohs(words[i++])));
			}
			return result;
		}
	}
	
	poco_socklen_t length() const
	{
		return sizeof(_addr);
	}

	const void* addr() const
	{
		return &_addr;
	}

	Address::Family family() const
	{
		return Address::IPv6;
	}

	int af() const
	{
		return AF_INET6;
	}

	bool isWildcard() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return words[0] == 0 && words[1] == 0 && words[2] == 0 && words[3] == 0 && 
		       words[4] == 0 && words[5] == 0 && words[6] == 0 && words[7] == 0;
	}
	
	bool isBroadcast() const
	{
		return false;
	}
	
	bool isLoopback() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return words[0] == 0 && words[1] == 0 && words[2] == 0 && words[3] == 0 && 
		       words[4] == 0 && words[5] == 0 && words[6] == 0 && words[7] == 1;
	}
	
	bool isMulticast() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return (words[0] & 0xFFE0) == 0xFF00;
	}
		
	bool isLinkLocal() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return (words[0] & 0xFFE0) == 0xFE80;
	}
	
	bool isSiteLocal() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return (words[0] & 0xFFE0) == 0xFEC0;
	}
	
	bool isIPv4Compatible() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return words[0] == 0 && words[1] == 0 && words[2] == 0 && words[3] == 0 && words[4] == 0 && words[5] == 0;
	}

	bool isIPv4Mapped() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return words[0] == 0 && words[1] == 0 && words[2] == 0 && words[3] == 0 && words[4] == 0 && words[5] == 0xFFFF;
	}

	bool isWellKnownMC() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return (words[0] & 0xFFF0) == 0xFF00;
	}
	
	bool isNodeLocalMC() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return (words[0] & 0xFFEF) == 0xFF01;
	}
	
	bool isLinkLocalMC() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return (words[0] & 0xFFEF) == 0xFF02;
	}
	
	bool isSiteLocalMC() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return (words[0] & 0xFFEF) == 0xFF05;
	}
	
	bool isOrgLocalMC() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return (words[0] & 0xFFEF) == 0xFF08;
	}
	
	bool isGlobalMC() const
	{
		const UInt16* words = reinterpret_cast<const UInt16*>(&_addr);
		return (words[0] & 0xFFEF) == 0xFF0F;
	}

	static IPv6AddressImpl* parse(const std::string& addr)
	{
		if (addr.empty()) return 0;
#if defined(_WIN32)
		struct addrinfo* pAI;
		struct addrinfo hints;
		std::memset(&hints, 0, sizeof(hints));
		hints.ai_flags = AI_NUMERICHOST;
		int rc = getaddrinfo(addr.c_str(), NULL, &hints, &pAI);
		if (rc == 0)
		{
			IPv6AddressImpl* pResult = new IPv6AddressImpl(&reinterpret_cast<struct sockaddr_in6*>(pAI->ai_addr)->sin6_addr);
			freeaddrinfo(pAI);
			return pResult;
		}
		else return 0;
#else
		struct in6_addr ia;
		if (inet_pton(AF_INET6, addr.c_str(), &ia) == 1)
			return new IPv6AddressImpl(&ia);
		else
			return 0;
#endif
	}
	
	void mask(const AddressImpl* pMask, const AddressImpl* pSet)
	{
		throw Poco::NotImplementedException("mask() is only supported for IPv4 addresses");
	}

	AddressImpl* clone() const
	{
		return new IPv6AddressImpl(&_addr);
	}

private:
	struct in6_addr _addr;	
};


#endif // POCO_HAVE_IPv6


#ifdef POCO_OS_FAMILY_UNIX


class LocalAddressImpl: public AddressImpl
{
public:
	LocalAddressImpl()
	{
		std::memset(&_addr, 0, sizeof(_addr));
	}
	
	LocalAddressImpl(const void* addr)
	{
		std::memcpy(&_addr, addr, sizeof(_addr));
	}
	
	std::string toString() const
	{
		std::string result(_addr.sun_path);
		return result;
	}

	poco_socklen_t length() const
	{
		return SUN_LEN(&_addr);
	}
	
	const void* addr() const
	{
		return &_addr;
	}
	
	Address::Family family() const
	{
		return Address::LOCAL;
	}
	
	int af() const
	{
		return AF_LOCAL;
	}
	
	bool isWildcard() const
	{
		return false;
	}
	
	bool isBroadcast() const
	{
		return false;
	}
	
	bool isLoopback() const
	{
		return false;
	}
	
	bool isMulticast() const
	{
		return false;
	}
		
	bool isLinkLocal() const
	{
		return true;
	}
	
	bool isSiteLocal() const
	{
		return true;
	}
	
	bool isIPv4Compatible() const
	{
		return false;
	}

	bool isIPv4Mapped() const
	{
		return false;
	}

	bool isWellKnownMC() const
	{
		return false;
	}
	
	bool isNodeLocalMC() const
	{
		return false;
	}
	
	bool isLinkLocalMC() const
	{
		return false;
	}
	
	bool isSiteLocalMC() const
	{
		return false;
	}
	
	bool isOrgLocalMC() const
	{
		return false;
	}
	
	bool isGlobalMC() const
	{
		return false;
	}

	static LocalAddressImpl* parse(const std::string& addr)
	{
		struct sockaddr_un ua;

		if (addr.empty() ||
			addr.size() >= sizeof(ua.sun_path)) return 0;		

		ua.sun_family = AF_LOCAL;
		std::memset(&ua.sun_path, 0, sizeof(ua.sun_path));
		std::memcpy(ua.sun_path, addr.data(), addr.size());
		return new LocalAddressImpl(&ua);
	}
	
	void mask(const AddressImpl* pMask, const AddressImpl* pSet)
	{
		return;
	}
	
	AddressImpl* clone() const
	{
		return new LocalAddressImpl(&_addr);
	}
		
private:
	struct sockaddr_un _addr;	
};


#endif //POCO_OS_FAMILY_UNIX


//
// Address
//


Address::Address(): _pImpl(new IPv4AddressImpl)
{
}


Address::Address(const Address& addr): _pImpl(addr._pImpl)
{
	_pImpl->duplicate();
}


Address::Address(Family family): _pImpl(0)
{
	if (family == IPv4)
		_pImpl = new IPv4AddressImpl();
#if defined(POCO_HAVE_IPv6)
	else if (family == IPv6)
		_pImpl = new IPv6AddressImpl();
#endif
#ifdef POCO_OS_FAMILY_UNIX
	else if (family == LOCAL)
		_pImpl = new LocalAddressImpl();
#endif
	else Poco::InvalidArgumentException("Invalid or unsupported address family passed to Address()");
}


Address::Address(const std::string& addr)
{
	if (!addr.empty() && 0 != std::isdigit(addr[0]))
		_pImpl = IPv4AddressImpl::parse(addr);
#if defined(POCO_HAVE_IPv6)
	if (!_pImpl && !addr.empty() && '[' == addr[0])
		_pImpl = IPv6AddressImpl::parse(addr);
#endif
#ifdef POCO_OS_FAMILY_UNIX
	if (!_pImpl&& !addr.empty() && std::string::npos != addr.find("/"))
		_pImpl = LocalAddressImpl::parse(addr);
#endif
	if (!_pImpl) throw InvalidAddressException(addr);
}


Address::Address(const std::string& addr, Family family): _pImpl(0)
{
	if (family == IPv4)
		_pImpl = IPv4AddressImpl::parse(addr);
#if defined(POCO_HAVE_IPv6)
	else if (family == IPv6)
		_pImpl = IPv6AddressImpl::parse(addr);
#endif
#ifdef POCO_OS_FAMILY_UNIX
	else if (family == LOCAL)
		_pImpl = LocalAddressImpl::parse(addr);
#endif
	else throw Poco::InvalidArgumentException("Invalid or unsupported address family passed to Address()");
	if (!_pImpl) throw InvalidAddressException(addr);
}


Address::Address(const void* addr, poco_socklen_t length)
{
	if (length == sizeof(struct in_addr))
		_pImpl = new IPv4AddressImpl(addr);
#if defined(POCO_HAVE_IPv6)
	else if (length == sizeof(struct in6_addr))
		_pImpl = new IPv6AddressImpl(addr);
#endif
#ifdef POCO_OS_FAMILY_UNIX
	if (0 == _pImpl)
		_pImpl = new LocalAddressImpl(addr);
#endif
	if (0 == _pImpl) 
		throw Poco::InvalidArgumentException("Invalid address length passed to Address()");
}


Address::~Address()
{
	_pImpl->release();
}


Address& Address::operator = (const Address& addr)
{
	if (&addr != this)
	{
		_pImpl->release();
		_pImpl = addr._pImpl;
		_pImpl->duplicate();
	}
	return *this;
}


void Address::swap(Address& address)
{
	std::swap(_pImpl, address._pImpl);
}

	
Address::Family Address::family() const
{
	return _pImpl->family();
}

	
std::string Address::toString() const
{
	return _pImpl->toString();
}


bool Address::isWildcard() const
{
	return _pImpl->isWildcard();
}
	
bool Address::isBroadcast() const
{
	return _pImpl->isBroadcast();
}


bool Address::isLoopback() const
{
	return _pImpl->isLoopback();
}


bool Address::isMulticast() const
{
	return _pImpl->isMulticast();
}

	
bool Address::isUnicast() const
{
	return !isWildcard() && !isBroadcast() && !isMulticast();
}

	
bool Address::isLinkLocal() const
{
	return _pImpl->isLinkLocal();
}


bool Address::isSiteLocal() const
{
	return _pImpl->isSiteLocal();
}


bool Address::isIPv4Compatible() const
{
	return _pImpl->isIPv4Compatible();
}


bool Address::isIPv4Mapped() const
{
	return _pImpl->isIPv4Mapped();
}


bool Address::isWellKnownMC() const
{
	return _pImpl->isWellKnownMC();
}


bool Address::isNodeLocalMC() const
{
	return _pImpl->isNodeLocalMC();
}


bool Address::isLinkLocalMC() const
{
	return _pImpl->isLinkLocalMC();
}


bool Address::isSiteLocalMC() const
{
	return _pImpl->isSiteLocalMC();
}


bool Address::isOrgLocalMC() const
{
	return _pImpl->isOrgLocalMC();
}


bool Address::isGlobalMC() const
{
	return _pImpl->isGlobalMC();
}


bool Address::operator == (const Address& a) const
{
	poco_socklen_t l1 = length();
	poco_socklen_t l2 = a.length();
	if (l1 == l2)
		return std::memcmp(addr(), a.addr(), l1) == 0;
	else
		return false;
}


bool Address::operator != (const Address& a) const
{
	poco_socklen_t l1 = length();
	poco_socklen_t l2 = a.length();
	if (l1 == l2)
		return std::memcmp(addr(), a.addr(), l1) != 0;
	else
		return true;
}


bool Address::operator < (const Address& a) const
{
	poco_socklen_t l1 = length();
	poco_socklen_t l2 = a.length();
	if (l1 == l2)
		return std::memcmp(addr(), a.addr(), l1) < 0;
	else
		return l1 < l2;
}


bool Address::operator <= (const Address& a) const
{
	poco_socklen_t l1 = length();
	poco_socklen_t l2 = a.length();
	if (l1 == l2)
		return std::memcmp(addr(), a.addr(), l1) <= 0;
	else
		return l1 < l2;
}


bool Address::operator > (const Address& a) const
{
	poco_socklen_t l1 = length();
	poco_socklen_t l2 = a.length();
	if (l1 == l2)
		return std::memcmp(addr(), a.addr(), l1) > 0;
	else
		return l1 > l2;
}


bool Address::operator >= (const Address& a) const
{
	poco_socklen_t l1 = length();
	poco_socklen_t l2 = a.length();
	if (l1 == l2)
		return std::memcmp(addr(), a.addr(), l1) >= 0;
	else
		return l1 > l2;
}


poco_socklen_t Address::length() const
{
	return _pImpl->length();
}

	
const void* Address::addr() const
{
	return _pImpl->addr();
}


int Address::af() const
{
	return _pImpl->af();
}


void Address::init(AddressImpl* pImpl)
{
	_pImpl->release();
	_pImpl = pImpl;
}


Address Address::parse(const std::string& addr)
{
	return Address(addr);
}


bool Address::tryParse(const std::string& addr, Address& result)
{
	AddressImpl* pImpl = 0;

	if (!addr.empty() && 0 != std::isdigit(addr[0])) 
		pImpl = IPv4AddressImpl::parse(addr);
#if defined(POCO_HAVE_IPv6)
	if (!pImpl && !addr.empty() && '[' == addr[0]))
		pImpl = IPv6AddressImpl::parse(addr);
#endif
#ifdef POCO_OS_FAMILY_UNIX
	if (!pImpl && std::string::npos != addr.find("/"))
		pImpl = LocalAddressImpl::parse(addr);
#endif
	if (pImpl)
	{
		result.init(pImpl);
		return true;
	}
	else return false;
}


void Address::mask(const Address& mask)
{
	AddressImpl* pClone = _pImpl->clone();
	_pImpl->release();
	_pImpl = pClone;
	Address null;
	_pImpl->mask(mask._pImpl, null._pImpl);
}


void Address::mask(const Address& mask, const Address& set)
{
	AddressImpl* pClone = _pImpl->clone();
	_pImpl->release();
	_pImpl = pClone;
	_pImpl->mask(mask._pImpl, set._pImpl);
}


} } // namespace Poco::Sockets
