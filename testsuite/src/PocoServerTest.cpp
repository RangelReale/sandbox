//
// PocoServerTest.cpp
//
// Library: TestSuite
// Package: Servers
// Module:  PocoServerTest
//
// Copyright (c) 2006, Aleksandar Fabijanic and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "PocoServerTest.h"
#include "CppUnit/TestCaller.h"
#include "CppUnit/TestSuite.h"
#include "Poco/Servlet/PocoServer/PocoHttpServletRequest.h"
#include "Poco/Servlet/PocoServer/PocoHttpServletResponse.h"
#include "Poco/Servlet/ServletInputStream.h"
#include "Poco/Servlet/ServletOutputStream.h"
#include "Poco/Servlet/Ex/HttpServletDispatcher.h"
#include "Poco/Servlet/Ex/PathMapping.h"
#include "Poco/Servlet/Container/ConfigImpl.h"
#include "Poco/Servlet/Container/ServletContextImpl.h"
#include "Poco/Servlet/Container/FilterChainImpl.h"
#include "Poco/Net/HTTPServer.h"
#include "Poco/Net/HTTPServerParams.h"
#include "Poco/Net/HTTPRequestHandler.h"
#include "Poco/Net/HTTPRequestHandlerFactory.h"
#include "Poco/Net/HTTPClientSession.h"
#include "Poco/Net/HTTPRequest.h"
#include "Poco/Net/HTTPServerRequest.h"
#include "Poco/Net/HTTPResponse.h"
#include "Poco/Net/HTTPServerResponse.h"
#include "Poco/Net/ServerSocket.h"
#include "Poco/StreamCopier.h"
#include "Poco/Environment.h"
#include "Poco/Exception.h"


using Poco::Net::HTTPServer;
using Poco::Net::HTTPServerParams;
using Poco::Net::HTTPRequestHandler;
using Poco::Net::HTTPRequestHandlerFactory;
using Poco::Net::HTTPClientSession;
using Poco::Net::HTTPRequest;
using Poco::Net::HTTPServerRequest;
using Poco::Net::HTTPResponse;
using Poco::Net::HTTPServerResponse;
using Poco::Net::HTTPMessage;
using Poco::Net::ServerSocket;
using Poco::StreamCopier;
using Poco::Environment;
using Poco::NotFoundException;
using Poco::Servlet::Filter;
using Poco::Servlet::FilterChain;
using Poco::Servlet::HttpServlet;
using Poco::Servlet::HttpServletRequest;
using Poco::Servlet::HttpServletResponse;
using Poco::Servlet::ServletRequest;
using Poco::Servlet::ServletResponse;
using Poco::Servlet::ServletOutputStream;
using Poco::Servlet::Ex::HttpServletDispatcher;
using Poco::Servlet::Ex::PathMapping;
using Poco::Servlet::Container::ServletContextImpl;
using Poco::Servlet::Container::ServletConfigImpl;
using Poco::Servlet::Container::FilterChainImpl;
using Poco::Servlet::PocoServer::PocoHttpServletRequest;
using Poco::Servlet::PocoServer::PocoHttpServletResponse;


std::string getBase()
{
	std::string base;

	try
	{
		base = Environment::get("POCO_BASE");
	}catch(NotFoundException&)
	{
		base = ".";
	}
  
	base += "/Servlet/runtime/";

	return base;
}


void doService(HttpServlet& s, HTTPServerRequest& request, HTTPServerResponse& response)
{
	if (request.getChunkedTransferEncoding())
		response.setChunkedTransferEncoding(true);
	else if (request.getContentLength() != HTTPMessage::UNKNOWN_CONTENT_LENGTH)
		response.setContentLength(request.getContentLength());
	
	response.setContentType(request.getContentType());

	PocoHttpServletRequest sRequest(request);
	PocoHttpServletResponse sResponse(response);

	HttpServletDispatcher servletDispatcher;
	ServletContextImpl context(getBase() + "Servlet/runtime/webapps/ServletTest/", servletDispatcher);
	s.init(new ServletConfigImpl(context));
	s.service(dynamic_cast<ServletRequest&>(sRequest), dynamic_cast<ServletResponse&>(sResponse));
}


class EchoServlet : public HttpServlet
{
public:
	void doGet(HttpServletRequest& req, HttpServletResponse& resp)
	{
		ServletOutputStream& out = resp.getOutputStream();
		out.print("<html></html>");
		out.flush();
	}

	void doPost(HttpServletRequest& req, HttpServletResponse& resp)
	{
		echo(req, resp);
	}

	void init()
	{
		SUPPORTED_METHODS.push_back("doGet");
		SUPPORTED_METHODS.push_back("doHead");
		SUPPORTED_METHODS.push_back("doPost");
	}

private:
	int echo(HttpServletRequest& req, HttpServletResponse& resp)
	{
		std::istream& istr = req.getInputStream();
		std::ostream& ostr = resp.getOutputStream();
		int n = StreamCopier::copyStream(istr, ostr);
		resp.getOutputStream().flush();
		return n;
	}
};


class FilteredServlet : public HttpServlet
{
public:
	void doGet(HttpServletRequest& req, HttpServletResponse& resp)
	{
		ServletOutputStream& out = resp.getOutputStream();
		out.print("FilteredServlet");
		out.flush();
	}
};


class TestFilter : public Filter
{
public: 

	void doFilter(ServletRequest& request, ServletResponse& response, const FilterChain* chain) const
	{
		ServletOutputStream& out = response.getOutputStream();
		out << "TestFilter=>";
		if(chain) chain->doFilter(request, response);
	}
};


class ChainFilter1 : public Filter
{
public: 

	void doFilter(ServletRequest& request, ServletResponse& response, const FilterChain* chain) const
	{
		ServletOutputStream& out = response.getOutputStream();
		out << "ChainFilter1=>";
		if(chain) chain->doFilter(request, response);
	}
};


class ChainFilter2 : public Filter
{
public: 

	void doFilter(ServletRequest& request, ServletResponse& response, const FilterChain* chain) const
	{
		ServletOutputStream& out = response.getOutputStream();
		out << "ChainFilter2=>";
		if(chain) chain->doFilter(request, response);
	}
};


class HttpServletRequestHandler: public HTTPRequestHandler
{
public:
	void handleRequest(HTTPServerRequest& request, HTTPServerResponse& response)
	{
		HttpServlet hs;
		doService(hs, request, response);
	}
};


class EchoServletRequestHandler: public HTTPRequestHandler
{
public:
	void handleRequest(HTTPServerRequest& request, HTTPServerResponse& response)
	{
		EchoServlet es;
		doService(es, request, response);
	}
};


class FilterRequestHandler: public HTTPRequestHandler
{
public:
	void handleRequest(HTTPServerRequest& request, HTTPServerResponse& response)
	{
		if (request.getChunkedTransferEncoding())
			response.setChunkedTransferEncoding(true);
		else if (request.getContentLength() != HTTPMessage::UNKNOWN_CONTENT_LENGTH)
			response.setContentLength(request.getContentLength());
		
		response.setContentType(request.getContentType());

		PocoHttpServletRequest sRequest(request);
		PocoHttpServletResponse sResponse(response);

		ChainFilter1 cf1;
		FilterChainImpl fci(&cf1);

		ChainFilter2 cf2;
		fci.appendFilter(&cf2);
		
		FilteredServlet fs;
		HttpServletDispatcher servletDispatcher;
		ServletContextImpl context(getBase() + "Servlet/runtime/webapps/ServletTest/", servletDispatcher);
		fs.init(new ServletConfigImpl(context));
		fci.setServlet(&fs);
		TestFilter tf;
		tf.doFilter(sRequest, sResponse, &fci);
	}
};


class RequestHandlerFactory: public HTTPRequestHandlerFactory
{
public:
	HTTPRequestHandler* createRequestHandler(const HTTPServerRequest& request)
	{
		if (request.getURI() == PocoServerTest::HTTP_SERVLET_URI) return new HttpServletRequestHandler;
		else if (request.getURI() == PocoServerTest::ECHO_SERVLET_URI) return new EchoServletRequestHandler;
		else if (request.getURI() == PocoServerTest::FILTER_URI) return new FilterRequestHandler;
		else return 0;
	}
};


const std::string PocoServerTest::HTTP_SERVLET_URI = "/HttpServlet";
const std::string PocoServerTest::ECHO_SERVLET_URI = "/EchoServlet";
const std::string PocoServerTest::FILTER_URI = "/TestFilter";


PocoServerTest::PocoServerTest(const std::string& name): CppUnit::TestCase(name)
{
}


PocoServerTest::~PocoServerTest()
{
}


void PocoServerTest::testFilter()
{
	ServerSocket svs(0);
	HTTPServerParams* pParams = new HTTPServerParams;
	pParams->setKeepAlive(false);
	HTTPServer srv(new RequestHandlerFactory, svs, pParams);
	srv.start();
	
	HTTPClientSession cs("localhost", svs.address().port());
	HTTPRequest request("GET", FILTER_URI);
	request.setContentType("text/plain");
	cs.sendRequest(request);
	
	std::string rbody;
	HTTPResponse response;
	cs.receiveResponse(response) >> rbody;
	assert(response.getStatus() == HTTPResponse::HTTP_OK);
	assert ("TestFilter=>ChainFilter1=>ChainFilter2=>FilteredServlet" == rbody);
}


void PocoServerTest::testHttpServlet()
{
	HTTPResponse response1;
	testHttpServletMethodNoBody("GET", response1);
	assert(response1.getStatus() == HTTPResponse::HTTP_METHOD_NOT_ALLOWED);

	HTTPResponse response2;
	testHttpServletMethodNoBody("HEAD", response2);
	assert(response2.getStatus() == HTTPResponse::HTTP_METHOD_NOT_ALLOWED);

	HTTPResponse response3;
	testHttpServletMethodNoBody("POST", response3);
	assert(response3.getStatus() == HTTPResponse::HTTP_METHOD_NOT_ALLOWED);

	HTTPResponse response4;
	testHttpServletMethodNoBody("PUT", response4);
	assert(response4.getStatus() == HTTPResponse::HTTP_METHOD_NOT_ALLOWED);

	HTTPResponse response5;
	testHttpServletMethodNoBody("DELETE", response5);
	assert(response5.getStatus() == HTTPResponse::HTTP_METHOD_NOT_ALLOWED);

	HTTPResponse response6;
	testHttpServletMethodNoBody("OPTIONS", response6);
	assert(response6.getStatus() == HTTPResponse::HTTP_OK);
	std::string allow = response6.get("Allow");
	assert(allow.find("TRACE") != allow.npos);
	assert(allow.find("OPTIONS") != allow.npos);

	HTTPResponse response7;
	testHttpServletMethodNoBody("TRACE", response7);
	assert(response7.getStatus() == HTTPResponse::HTTP_OK);
	assert(response7.get("Content-Type") == "message/http");
}


void PocoServerTest::testHttpServletMethodNoBody(const std::string& method, HTTPResponse& response)
{
	ServerSocket svs(0);
	HTTPServerParams* pParams = new HTTPServerParams;
	pParams->setKeepAlive(false);
	HTTPServer srv(new RequestHandlerFactory, svs, pParams);
	srv.start();
	
	HTTPClientSession cs("localhost", svs.address().port());
	HTTPRequest request(method, HTTP_SERVLET_URI);
	request.setContentType("text/plain");
	cs.sendRequest(request);
	
	cs.receiveResponse(response);
}


void PocoServerTest::testConcreteServlet()
{
	testGet();
	testPost();
	testHead(); 

	HTTPResponse response;
	testHttpServletMethodNoBody("OPTIONS", response);
	assert(response.getStatus() == HTTPResponse::HTTP_OK);
	std::string allow = response.get("Allow");
	assert(allow.find("GET") != allow.npos);
	assert(allow.find("POST") != allow.npos);
	assert(allow.find("HEAD") != allow.npos);
	assert(allow.find("TRACE") != allow.npos);
	assert(allow.find("OPTIONS") != allow.npos);
}


void PocoServerTest::testGet()
{
	ServerSocket svs(0);
	HTTPServerParams* pParams = new HTTPServerParams;
	pParams->setKeepAlive(false);
	HTTPServer srv(new RequestHandlerFactory, svs, pParams);
	srv.start();
	
	HTTPClientSession cs("localhost", svs.address().port());
	HTTPRequest request("GET", ECHO_SERVLET_URI);
	request.setContentType("text/plain");
	cs.sendRequest(request);
	
	std::string rbody;
	HTTPResponse response;
	cs.receiveResponse(response) >> rbody;
	assert(response.getStatus() == HTTPResponse::HTTP_OK);
	assert ("<html></html>" == rbody);
}


void PocoServerTest::testPost()
{
	ServerSocket svs(0);
	HTTPServerParams* pParams = new HTTPServerParams;
	pParams->setKeepAlive(false);
	HTTPServer srv(new RequestHandlerFactory, svs, pParams);
	srv.start();
	
	HTTPClientSession cs("localhost", svs.address().port());
	std::string body(100, 'x');
	HTTPRequest request("POST", ECHO_SERVLET_URI);
	request.setContentType("text/plain");
	cs.sendRequest(request) << body;
	
	std::string rbody;
	HTTPResponse response;
	cs.receiveResponse(response) >> rbody;
	assert(response.getStatus() == HTTPResponse::HTTP_OK);
	assert (body == rbody);
}


void PocoServerTest::testHead()
{
	ServerSocket svs(0);
	HTTPServerParams* pParams = new HTTPServerParams;
	pParams->setKeepAlive(false);
	HTTPServer srv(new RequestHandlerFactory, svs, pParams);
	srv.start();
	
	HTTPClientSession cs("localhost", svs.address().port());
	HTTPRequest request("HEAD", ECHO_SERVLET_URI);
	request.setContentType("text/plain");
	cs.sendRequest(request);
	
	std::string rbody;
	HTTPResponse response;
	cs.receiveResponse(response) >> rbody;
	assert(response.getStatus() == HTTPResponse::HTTP_OK);
	assert ("" == rbody);
}


void PocoServerTest::testPocoServer()
{
	
}


void PocoServerTest::setUp()
{

}


void PocoServerTest::tearDown()
{
	
}


CppUnit::Test* PocoServerTest::suite()
{
	CppUnit::TestSuite* pSuite = new CppUnit::TestSuite("PocoServerTest");

	CppUnit_addTest(pSuite, PocoServerTest, testHttpServlet);
	CppUnit_addTest(pSuite, PocoServerTest, testConcreteServlet);
	CppUnit_addTest(pSuite, PocoServerTest, testFilter);
	CppUnit_addTest(pSuite, PocoServerTest, testPocoServer);
  
	return pSuite;
}
