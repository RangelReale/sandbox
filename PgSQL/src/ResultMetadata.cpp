//
// PgSQLException.cpp
//
// $Id: //poco/1.4/Data/PgSQL/src/ResultMetadata.cpp#1 $
//
// Library: Data
// Package: PgSQL
// Module:  ResultMetadata
//
// Copyright (c) 2008, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Data/PgSQL/ResultMetadata.h"
#include "Poco/Data/PgSQL/PgSQLException.h"
#include "Poco/Data/PgSQL/PgSQLInternal.h"
#include <cstring>

namespace
{
	class ResultMetadataHandle
		/// Simple exception-safe wrapper
	{
	public:

		explicit ResultMetadataHandle(PGresult* stmt)
		{
			h = stmt;
		}

		~ResultMetadataHandle()
		{
			if (h)
			{
				PQclear(h);
			}
		}

		operator PGresult* ()
		{
			return h;
		}

	private:

		PGresult* h;
	};
/*
	std::size_t fieldSize(const PgSQL_FIELD& field)
		/// Convert field PgSQL-type and field PgSQL-length to actual field length
	{
		switch (field.type)
		{
		case PgSQL_TYPE_TINY:     return sizeof(char);
		case PgSQL_TYPE_SHORT:    return sizeof(short);
		case PgSQL_TYPE_INT24:
		case PgSQL_TYPE_LONG:     return sizeof(Poco::Int32);
		case PgSQL_TYPE_FLOAT:    return sizeof(float);
		case PgSQL_TYPE_DOUBLE:   return sizeof(double);
		case PgSQL_TYPE_LONGLONG: return sizeof(Poco::Int64);

		case PgSQL_TYPE_DATE:
		case PgSQL_TYPE_TIME:
		case PgSQL_TYPE_DATETIME:
			return sizeof(PgSQL_TIME);

		case PgSQL_TYPE_DECIMAL:
		case PgSQL_TYPE_NEWDECIMAL:
		case PgSQL_TYPE_STRING:
		case PgSQL_TYPE_VAR_STRING:
		case PgSQL_TYPE_TINY_BLOB:
		case PgSQL_TYPE_MEDIUM_BLOB:
		case PgSQL_TYPE_LONG_BLOB:
		case PgSQL_TYPE_BLOB:
			return field.length;

		default:
			throw Poco::Data::PgSQL::StatementException("unknown field type");
		}
	}
*/

	Poco::Data::MetaColumn::ColumnDataType fieldType(int oid)
		/// Convert field PgSQL-type to Poco-type
	{
	    // FIXME
		bool unsig = false;

		switch (oid)
		{
		case PgSQL_TYPE_INT8:
			if (unsig) return Poco::Data::MetaColumn::FDT_UINT8;
			return Poco::Data::MetaColumn::FDT_INT8;

		case PgSQL_TYPE_INT16:
			if (unsig) return Poco::Data::MetaColumn::FDT_UINT16;
			return Poco::Data::MetaColumn::FDT_INT16;

		case PgSQL_TYPE_INT32:
			if (unsig) return Poco::Data::MetaColumn::FDT_UINT32;
			return Poco::Data::MetaColumn::FDT_INT32;

		case PgSQL_TYPE_FLOAT:
			return Poco::Data::MetaColumn::FDT_FLOAT;

		case PgSQL_TYPE_DOUBLE:
			return Poco::Data::MetaColumn::FDT_DOUBLE;

		case PgSQL_TYPE_INT64:
			if (unsig) return Poco::Data::MetaColumn::FDT_UINT64;
			return Poco::Data::MetaColumn::FDT_INT64;

		case PgSQL_TYPE_STRING:
			return Poco::Data::MetaColumn::FDT_STRING;

		case PgSQL_TYPE_BYTEARRAY:
			return Poco::Data::MetaColumn::FDT_BLOB;
		default:
			return Poco::Data::MetaColumn::FDT_UNKNOWN;
		}
	}

} // namespace


namespace Poco {
namespace Data {
namespace PgSQL {

void ResultMetadata::reset()
{
	_columns.resize(0);
	_row.resize(0);
}

void ResultMetadata::init(PGresult* res)
{
	ResultMetadataHandle h(res);

	if (!h)
	{
		// all right, it is normal
		// querys such an "INSERT INTO" just does not have result at all
		reset();
		return;
	}

	std::size_t columns = PQnfields(res);
	_columns.reserve(columns);

	for (std::size_t i = 0; i < columns; i++)
	{
		_columns.push_back(MetaColumn(
			i,                               // position
			PQfname(res, i),                 // name
			fieldType(PQftype(res, i)),      // type
			PQfsize(res, i),                 // length
			PQfmod(res, i),                  // precision
			true                             // nullable FIXME:
			)
		);
	}

	_row.resize(columns);

	for (std::size_t i = 0; i < columns; i++)
	{
		_row[i] = PgSQL_BIND(
		    PQftype(res, i),
		    PQgetvalue(res, 0, i), // FIXME: real dat or metadata?
		    PQfsize(res, i)
		    );
	}
}

std::size_t ResultMetadata::columnsReturned() const
{
	return static_cast<std::size_t>(_columns.size());
}

const MetaColumn& ResultMetadata::metaColumn(std::size_t pos) const
{
	return _columns[pos];
}

PgSQL_BIND* ResultMetadata::row()
{
	return &_row[0];
}

std::size_t ResultMetadata::length(std::size_t pos) const
{
	return metaColumn(pos).length();
}

const unsigned char* ResultMetadata::rawData(std::size_t pos) const
{
	return reinterpret_cast<const unsigned char*>(_row[pos]._paramValue.data());
}

bool ResultMetadata::isNull(std::size_t pos) const
{
	return metaColumn(pos).isNullable();
}

}}} // namespace Poco::Data::PgSQL
