//
// PgSQLException.cpp
//
// $Id: //poco/1.4/Data/PgSQL/src/SessionImpl.cpp#1 $
//
// Library: Data
// Package: PgSQL
// Module:  SessionImpl
//
// Copyright (c) 2008, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Data/PgSQL/SessionImpl.h"
#include "Poco/Data/PgSQL/PgSQLStatementImpl.h"
#include "Poco/Data/Session.h"
#include "Poco/NumberParser.h"
#include "Poco/String.h"


namespace
{
	std::string copyStripped(std::string::const_iterator from, std::string::const_iterator to)
	{
		// skip leading spaces
		while ((from != to) && isspace(*from)) from++;
		// skip trailing spaces
		while ((from != to) && isspace(*(to - 1))) to--;

		return std::string(from, to);
	}
}


namespace Poco {
namespace Data {
namespace PgSQL {


const std::string SessionImpl::PgSQL_READ_UNCOMMITTED = "READ UNCOMMITTED";
const std::string SessionImpl::PgSQL_READ_COMMITTED = "READ COMMITTED";
const std::string SessionImpl::PgSQL_REPEATABLE_READ = "REPEATABLE READ";
const std::string SessionImpl::PgSQL_SERIALIZABLE = "SERIALIZABLE";


SessionImpl::SessionImpl(const std::string& connectionString, std::size_t loginTimeout) :
	Poco::Data::AbstractSessionImpl<SessionImpl>(toLower(connectionString), loginTimeout),
	_handle(),
	_connected(false),
	_inTransaction(false)
{
	addProperty("insertId",
		&SessionImpl::setInsertId,
		&SessionImpl::getInsertId);

	open();
	setConnectionTimeout(CONNECTION_TIMEOUT_DEFAULT);
}


void SessionImpl::open(const std::string& connect)
{
	if (connect != connectionString())
	{
		if (isConnected())
			throw InvalidAccessException("Session already connected");

		if (!connect.empty())
			setConnectionString(connect);
	}

	poco_assert_dbg (!connectionString().empty());

	std::map<std::string, std::string> options;

	// Default values
	options["host"] = "localhost";
	options["port"] = "3306";
	options["user"] = "";
	options["password"] = "";
	options["dbname"] = "";
	options["auto_reconnect"] = "";
    options["client_encoding"] = "utf-8";

    unsigned int timeout = static_cast<unsigned int>(getLoginTimeout());
    options["connect_timeout"] = NumberFormatter::format(timeout);

	const std::string& connString = connectionString();
	for (std::string::const_iterator start = connString.begin();;)
	{
		std::string::const_iterator finish = std::find(start, connString.end(), ';');
		std::string::const_iterator middle = std::find(start, finish, '=');

		if (middle == finish)
			throw PgSQLException("create session: bad connection string format, can not find '='");

		options[copyStripped(start, middle)] = copyStripped(middle + 1, finish);

		if ((finish == connString.end()) || (finish + 1 == connString.end())) break;

		start = finish + 1;
	}

	if (options["user"] == "")
		throw PgSQLException("create session: specify user name");

	if (options["dbname"] == "")
		throw PgSQLException("create session: specify database");

	unsigned int port = 0;
	if (!NumberParser::tryParseUnsigned(options["port"], port) || 0 == port || port > 65535)
		throw PgSQLException("create session: specify correct port (numeric in decimal notation)");

	// Build connection string from the ground
	std::string conninfo;
	std::map<std::string, std::string>::iterator i = options.begin();
	std::map<std::string, std::string>::iterator e = options.end();
	while(i != e)
	{
	    conninfo += (i->first + "=" + i->second + " ");
	    ++i;
	}

	// Real connect
	_handle.connect(conninfo);

	addFeature("autoCommit",
		&SessionImpl::autoCommit,
		&SessionImpl::isAutoCommit);

	_connected = true;
}


SessionImpl::~SessionImpl()
{
	close();
}


Poco::Data::StatementImpl* SessionImpl::createStatementImpl()
{
	return new PgSQLStatementImpl(*this);
}


void SessionImpl::begin()
{
	Poco::FastMutex::ScopedLock l(_mutex);

	if (_inTransaction)
		throw Poco::InvalidAccessException("Already in transaction.");

    _handle.startTransaction();
	_inTransaction = true;
}


void SessionImpl::commit()
{
    _handle.commit();
	_inTransaction = false;
}


void SessionImpl::rollback()
{
    _handle.rollback();
	_inTransaction = false;
}


void SessionImpl::autoCommit(const std::string&, bool val)
{
	StatementExecutor ex(_handle);
	ex.prepare(Poco::format("SET autocommit=%d", val ? 1 : 0), 0, 0);
	ex.execute(0,0);
}


bool SessionImpl::isAutoCommit(const std::string&)
{
	int ac = 0;
	return 1 == getSetting("autocommit", ac);
}


void SessionImpl::setTransactionIsolation(Poco::UInt32 ti)
{
	std::string isolation;
	switch (ti)
	{
	case Session::TRANSACTION_READ_UNCOMMITTED:
		isolation = PgSQL_READ_UNCOMMITTED; break;
	case Session::TRANSACTION_READ_COMMITTED:
		isolation = PgSQL_READ_COMMITTED; break;
	case Session::TRANSACTION_REPEATABLE_READ:
		isolation = PgSQL_REPEATABLE_READ; break;
	case Session::TRANSACTION_SERIALIZABLE:
		isolation = PgSQL_SERIALIZABLE; break;
	default:
		throw Poco::InvalidArgumentException("setTransactionIsolation()");
	}

	StatementExecutor ex(_handle);
	ex.prepare(Poco::format("SET SESSION TRANSACTION ISOLATION LEVEL %s", isolation), 0, 0);
	ex.execute(0,0);
}


Poco::UInt32 SessionImpl::getTransactionIsolation()
{
	std::string isolation;
	getSetting("tx_isolation", isolation);
	Poco::replaceInPlace(isolation, "-", " ");
	if (PgSQL_READ_UNCOMMITTED == isolation)
		return Session::TRANSACTION_READ_UNCOMMITTED;
	else if (PgSQL_READ_COMMITTED == isolation)
		return Session::TRANSACTION_READ_COMMITTED;
	else if (PgSQL_REPEATABLE_READ == isolation)
		return Session::TRANSACTION_REPEATABLE_READ;
	else if (PgSQL_SERIALIZABLE == isolation)
		return Session::TRANSACTION_SERIALIZABLE;

	throw InvalidArgumentException("getTransactionIsolation()");
}


bool SessionImpl::hasTransactionIsolation(Poco::UInt32 ti)
{
	return Session::TRANSACTION_READ_UNCOMMITTED == ti ||
		Session::TRANSACTION_READ_COMMITTED == ti ||
		Session::TRANSACTION_REPEATABLE_READ == ti ||
		Session::TRANSACTION_SERIALIZABLE == ti;
}


void SessionImpl::close()
{
	if (_connected)
	{
		_handle.close();
		_connected = false;
	}
}


void SessionImpl::setConnectionTimeout(std::size_t timeout)
{
    // FIXME:
	//_handle.options(PgSQL_OPT_READ_TIMEOUT, static_cast<unsigned int>(timeout));
	//_handle.options(PgSQL_OPT_WRITE_TIMEOUT, static_cast<unsigned int>(timeout));
	_timeout = timeout;
}


}}}
