//
// StatementExecutor.cpp
//
// $Id$
//
// Library: Data
// Package: PgSQL
// Module:  StatementExecutor
//
// Copyright (c) 2008, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include <libpq-fe.h>
#include "Poco/Data/PgSQL/StatementExecutor.h"
#include <sstream>
#include <cstdlib>

namespace Poco {
namespace Data {
namespace PgSQL {


StatementExecutor::StatementExecutor(pg_conn* conn)
{
    _connection = conn;
	_result = 0;
	_state = STMT_INITED;
}


StatementExecutor::~StatementExecutor()
{
    if (_result)
        PQclear(_result);
}


int StatementExecutor::state() const
{
	return _state;
}


void StatementExecutor::prepare(const std::string& query, PgSQL_BIND* params, std::size_t count)
{
    if (_state >= STMT_COMPILED)
    {
        _state = STMT_COMPILED;
        return;
    }

    Oid* paramTypes = 0;

    if (params && count>0)
    {
        paramTypes = new Oid[count];
        for(std::size_t i = 0; i< count; ++i)
        {
            paramTypes[i] = params[i]._oid;
        }
    }

    _stmtName = getRandomName();

    _result = PQprepare(
        _connection,
        _stmtName.c_str(),
        query.c_str(),
        count,
        paramTypes
        );

    if (paramTypes)
        delete[] paramTypes;

    if (_result != 0)
        throw StatementException("PQprepare error", _result, query);

    // FIXME result status

    _query = query;
    _state = STMT_COMPILED;
}


void StatementExecutor::bindResult(PgSQL_BIND* result)
{
	if (_state < STMT_COMPILED)
		throw StatementException("Satement is not compiled yet");
/*
	if (PgSQL_stmt_bind_result(_pHandle, result) != 0)
		throw StatementException("PgSQL_stmt_bind_result error ", _pHandle, _query);
		*/
}


void StatementExecutor::execute(PgSQL_BIND* params, std::size_t count)
{
	if (_state < STMT_COMPILED)
		throw StatementException("Satement is not compiled yet");

    int* paramFormats = 0;
    char** paramValues = 0;
    int* paramLenghts = 0;

    if (params && count>0)
    {
        paramFormats = new int[count];
        paramValues = new char*[count];
        paramLenghts = new int[count];

        for(std::size_t i = 0; i< count; ++i)
        {
            paramFormats[i] = 1; // force binary format
            paramValues[i] = params[i]._paramValue.data();
            paramLenghts[i] = params[i]._paramLenght;
        }
    }

    _result = PQexecPrepared(_connection, _stmtName.c_str(), count, paramValues, paramLenghts, paramFormats, 1);

    if (paramFormats)
    {
        delete [] paramFormats;
        delete [] paramLenghts;
        delete [] paramValues;
    }

    if (_result != 0)
        throw StatementException("PgSQL_stmt_bind_param() error ", _result, _query);

    // FIXME result status

	_state = STMT_EXECUTED;
}


bool StatementExecutor::fetch()
{
	if (_state < STMT_EXECUTED)
		throw StatementException("Satement is not executed yet");
/*
	int res = PgSQL_stmt_fetch(_pHandle);

	if ((res != 0) && (res != PgSQL_NO_DATA))
		throw StatementException("PgSQL_stmt_fetch error", _pHandle, _query);

	return (res == 0);
	*/
	return true;
}


bool StatementExecutor::fetchColumn(std::size_t n, PgSQL_BIND *bind)
{
	if (_state < STMT_EXECUTED)
		throw StatementException("Satement is not executed yet");
#if 0
	int res = PgSQL_stmt_fetch_column(_pHandle, bind, static_cast<unsigned int>(n), 0);

	if ((res != 0) && (res != PgSQL_NO_DATA))
	{
		std::ostringstream msg;
		msg << "PgSQL_stmt_fetch_column(" << n << ") error";
		throw StatementException(msg.str(), _pHandle, _query);
	}

	return (res == 0);
#endif
	return true;
}

std::string StatementExecutor::getRandomName()
{
    char str[8] = "1234567";
    str[0] = char((rand()%96)+' ');
    str[1] = char((rand()%96)+' ');
    str[2] = char((rand()%96)+' ');
    str[3] = char((rand()%96)+' ');
    str[4] = char((rand()%96)+' ');
    str[5] = char((rand()%96)+' ');
    str[6] = char((rand()%96)+' ');
    str[7] = 0;
    return str;
}

}}}
