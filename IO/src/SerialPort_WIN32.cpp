//
// SerialPort_WIN32.cpp
//
// $Id: //poco/1.1.0/Foundation/src/IOPort_WIN32.cpp#1 $
//
// Library: IO
// Package: Serial
// Module:  SerialPort
//
// Copyright (c) 2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/IO/SerialPort_WIN32.h"
#include "Poco/Exception.h"
#include <windows.h>


using Poco::CreateFileException;

namespace Poco {
namespace IO {


SerialPortImpl::SerialPortImpl(const std::string& name, const SerialConfigImpl& config): 
	_name(name), _config(config)
{
	openImpl();
}


SerialPortImpl::~SerialPortImpl()
{
	closeImpl();
}


void SerialPortImpl::initImpl()
{
	DCB dcb;
	ZeroMemory(&dcb, sizeof(DCB));

	dcb.DCBlength = sizeof(DCB);
	dcb.ByteSize = _config.getDataBitsImpl();
	dcb.EofChar = _config.getEOFCharImpl();
	dcb.BaudRate = _config.getSpeedImpl();
	dcb.fParity = (_config.getParityImpl() != SerialConfigImpl::ParityImpl::NONE_IMPL);
	dcb.Parity = _config.getParityImpl();
	dcb.StopBits = _config.getStopBitsImpl();

	if (_config.getUseXonXoffImpl())
	{
		dcb.fOutX = TRUE;
		dcb.fInX = TRUE;
		dcb.XonChar = _config.getXonCharImpl();
		dcb.XoffChar = _config.getXoffCharImpl();
	}

	if (!SetCommState(_handle, &dcb)) handleError(_name);

	COMMTIMEOUTS cto;
	ZeroMemory(&cto, sizeof(COMMTIMEOUTS));

	cto.ReadIntervalTimeout = MAXDWORD ;
	cto.ReadTotalTimeoutMultiplier = MAXDWORD;
	cto.ReadTotalTimeoutConstant = _config.getTimeoutImpl();

	if (!SetCommTimeouts(_handle, &cto)) handleError(_name);

	DWORD bufSize = (DWORD) _config.getBufferSizeImpl();
	SetupComm(_handle, bufSize, bufSize);
}


void SerialPortImpl::reconfigureImpl(const SerialConfigImpl& config)
{
	_config = config;
	initImpl();
}

void SerialPortImpl::openImpl()
{
	_handle = CreateFile(_name.c_str(), GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (INVALID_HANDLE_VALUE == _handle) handleError(_name);

	initImpl();
}


void SerialPortImpl::closeImpl()
{
	if (!CloseHandle(_handle)) handleError(_name);
}


std::string& SerialPortImpl::readImpl(std::string& buffer)
{
	std::string* addr = &buffer;
	DWORD read = 0;
	int bufSize = _config.getBufferSizeImpl();
	char* pReadBuf = new char[bufSize+1];
	char eof = _config.getEOFCharImpl();
	SetFilePointer(_handle, 0, NULL, FILE_BEGIN);

	buffer = "";
	do
    {
		ZeroMemory(pReadBuf, bufSize+1); 
		if (!ReadFile(_handle, pReadBuf, bufSize, &read, NULL)) 
		{
			delete[] pReadBuf;
			handleError(_name);
		}

		poco_assert(read <= bufSize);
		buffer.append(pReadBuf, read);
		if (buffer.find(eof) != buffer.npos) break;
	}while(0 != read);

	delete[] pReadBuf;
	return buffer;
}


int SerialPortImpl::writeImpl(const std::string& data)
{
	DWORD dwWritten = 0;
	int length = data.length();

	if(!WriteFile(_handle, data.c_str(), length, &dwWritten, NULL) || (dwWritten != length))
		handleError(_name);

	return dwWritten;
}


const std::string& SerialPortImpl::getNameImpl() const
{
	return _name;
}


std::string& SerialPortImpl::getErrorText(std::string& buf)
{
	DWORD dwRet;
	LPTSTR pTemp = NULL;

	DWORD errCode = GetLastError();

	dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
		NULL,
		errCode,
		LANG_NEUTRAL,
		pTemp,
		0,
		NULL);

	if (dwRet && pTemp)
	{
		if ((std::string(pTemp).length()-2) >= 0)
		{
			pTemp[std::string(pTemp).length()-2] = TEXT('\0');  //remove cr and newline character
			buf = pTemp;
		}

		LocalFree((HLOCAL) pTemp);
	}
	return buf;
}

void SerialPortImpl::handleError(const std::string& name)
{
	std::string errorText;
	DWORD error = GetLastError();

	PurgeComm(_handle, PURGE_TXABORT|PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR);

	switch (error)
	{
	case ERROR_FILE_NOT_FOUND:
		throw FileNotFoundException(name, getErrorText(errorText));
	case ERROR_ACCESS_DENIED:
		throw FileAccessDeniedException(name, getErrorText(errorText));
	case ERROR_ALREADY_EXISTS:
	case ERROR_FILE_EXISTS:
		throw FileExistsException(name, getErrorText(errorText));
	case ERROR_FILE_READ_ONLY:
		throw FileReadOnlyException(name, getErrorText(errorText));
	case ERROR_CANNOT_MAKE:
	case ERROR_INVALID_NAME:
	case ERROR_FILENAME_EXCED_RANGE:
		throw CreateFileException(name, getErrorText(errorText));
	case ERROR_BROKEN_PIPE:
	case ERROR_INVALID_USER_BUFFER:
	case ERROR_INSUFFICIENT_BUFFER:
		throw IOException(name, getErrorText(errorText));
	case ERROR_NOT_ENOUGH_MEMORY:
		throw OutOfMemoryException(name, getErrorText(errorText));
	//following error occurs if the file was opened with FILE_FLAG_OVERLAPPED
	//and all the data was read so do nothing here
	case ERROR_HANDLE_EOF: break;
	default:
		throw FileException(name, getErrorText(errorText));
	}
}


} } // namespace Poco::IO
