// delimier_stream.h
//
// $Id:
//
// Library:
// Package:
// Module:
//
// Definition of the delimiter stream.
//
//
// Copyright  2007 Dieter Lucking
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


#ifndef POCO_DELIMITER_STREAM_H
#define POCO_DELIMITER_STREAM_H

#include "Poco/UnbufferedStreamBuf.h"
#include <istream>
#include <ostream>

namespace Poco {

// DelimiterCType
// ============================================================================

template <class Char, Char Delimiter>
class DelimiterCType : public std::ctype<Char>
/// A ctype implementation for streams holding values separated by a distinct
/// character.
{
    private:
    typedef typename std::ctype<Char> Base;

    public:
    typedef typename Base::mask mask;

    DelimiterCType()
	/// Creates a ctype favet having '"' as the quote character.
    :   m_delimit(true)
    {
		m_quote =  Base::do_widen('"');
		m_carriage_return = Base::do_widen('\r');
		m_newline = Base::do_widen('\n');
	}

	Char quote() const
	/// The quote character().
	{
	    return m_quote;
    }

	Char delimiter() const
	/// The delimiter character.
	{
        return Delimiter;
    }

	Char carriage_return() const
	/// The carriage return character().
	{
	    return m_carriage_return;
    }

    Char newline() const
	/// The new line character().
	{
	    return m_newline;
    }


    bool delimit() const
	/// Returns true if the delimiter character will be detected.
	{
		return m_delimit;
	}
	
    void delimit(bool value)
	/// Set the detection of the delimiter character on or off.
	{
		m_delimit = value;
	}

    protected:
    bool do_is(mask m, Char c) const {
		if(delimit() && (m & std::ctype_base::space)) {
			if(Delimiter == c || m_newline == c)
				return true;
		}
	    m &= ~std::ctype_base::space;
        return Base::do_is(m, c);
    }
    const Char* do_is(const Char* low, const Char* high, mask* result) const {
        Base::do_is(low, high, result);
		if(delimit()) {
			while(low < high) {
				if(Delimiter == *low || m_newline == *low)
					*result |= std::ctype_base::space;
				else *result &= ~std::ctype_base::space;
				++low;
				++result;
			}
		}
		else {
			mask* result_end = result + (high - low);
			while(result < result_end) *result++ &= ~std::ctype_base::space;
		}
        return high;
    }
    const Char* do_scan_is(mask m, const Char* low, const Char* high) const {
		const Char* sp = high;
		if(delimit() && (m & std::ctype_base::space)) {
			for(sp = low; sp < high; ++sp) {
				if(Delimiter == *sp && m_newline == *sp)
					break;
			}
		}
	    m &= ~std::ctype_base::space;
        return Base::do_is(m, low, sp);
    }

    const Char* do_scan_not(mask m, const Char* low, const Char* high) const {
		const Char* sp = high;
		if(delimit() && (m & std::ctype_base::space)) {
			for(sp = low; sp < high; ++sp) {
				if(Delimiter != *sp && m_newline != *sp)
					break;
			}
		}
        m &= ~std::ctype_base::space;
		if(! m) return sp;
		else return Base::do_not_is(m, low, sp);
    }

    private:
    bool m_delimit;
	Char m_quote;
	Char m_carriage_return;
	Char m_newline;
};


template<char Delimiter>
class DelimiterCType<char, Delimiter> : public std::ctype<char>
/// The ctype<char> implementation of DelimiterCTypes.
/// \see DelimiterCType
{
    private:
    typedef std::ctype<char> Base;
    const mask* allocate_table(const mask* table, bool del);

    public:
    DelimiterCType(const mask* table = 0, bool del = false, size_t refs = 0);
    ~DelimiterCType();

	char quote() const
	/// The quote character().
	{
	    return '"';
    }
	
	char delimiter() const
	/// The delimiter character.
	{
        return Delimiter;
    }

	char carriage_return() const
	/// The carriage return character().
	{
	    return '\r';
    }

	char newline() const
	/// The new line character().
	{
	    return '\n';
    }

    bool delimit() const
	/// Returns true if the delimiter character will be detected.
	{
			return m_delimit;
	}
	
    void delimit(bool value)
	/// Set the detection of the delimiter character on or off.
	{
        if(value) {
            m_csv_table[Delimiter] |= std::ctype_base::space;
            m_csv_table['\n'] |= std::ctype_base::space;
        }
        else {
            m_csv_table[Delimiter] &= ~std::ctype_base::space;
            m_csv_table['\n'] &= ~std::ctype_base::space;
        }
        m_delimit = value;
    }

    private:
    bool m_delimit;
    const mask* m_src_table;
    mask m_csv_table[Base::table_size];
};


template<char Delimiter>
const typename DelimiterCType<char, Delimiter>::mask*
DelimiterCType<char, Delimiter>::allocate_table(
    const mask* table, bool del)
{
    m_src_table = (table && del) ? table : 0;
    if(table == 0) {
        table = Base::classic_table();
        del = false;
    }
    const mask* src = table;
    const mask* src_end = table + Base::table_size;
    mask* dst = m_csv_table;
    for( ; src < src_end; ++dst, ++src) {
        *dst = *src & ~std::ctype_base::space;
    }
    m_csv_table[Delimiter] |= std::ctype_base::space;
    m_csv_table['\n'] |= std::ctype_base::space;
    return m_csv_table;
}

template<char Delimiter>
DelimiterCType<char, Delimiter>::DelimiterCType(
	const mask* table, bool del, size_t refs)
:   Base(allocate_table(table, del), false, refs), m_delimit(true)
{}

template<char Delimiter>
DelimiterCType<char, Delimiter>::~DelimiterCType() {
    if(m_src_table) {
        delete [] const_cast<mask*>(m_src_table);
    }
}


// BasicDelimiterBuffer
// ============================================================================

template < typename Char, Char Delimiter, typename Traits = std::char_traits<Char> >
class BasicDelimiterBuffer :  public Poco::BasicUnbufferedStreamBuf<Char, Traits>
/// A stream buffer for streams holding values separated by a distinct
/// character
{
	private:
	enum {
		Quoting = 1
	};
    protected:
   	typedef Poco::BasicUnbufferedStreamBuf<Char, Traits> Base;

    public:
	typedef typename Base::char_type char_type;
	typedef typename Base::int_type int_type;
	typedef typename Base::pos_type pos_type;
	typedef typename Base::off_type off_type;
	typedef typename Base::char_traits traits_type;

	BasicDelimiterBuffer(
		std::basic_ios<Char, Traits>& ios,
		std::basic_istream<Char, Traits>& is);
	/// Creates a BasicDelimiterBuffer and connects it to the given input stream.

	BasicDelimiterBuffer(
		std::basic_ios<Char, Traits>& ios,
		std::basic_ostream<Char, Traits>& os);
	/// Creates a BasicDelimiterBuffer and connects it to the given output stream.
		
	std::basic_istream<Char, Traits>* istream() const
	/// The attached input stream.
	{
	    return m_is;
	}
	
	std::basic_ostream<Char, Traits>* ostream() const
	/// The attached output stream.
	{
	    return m_os;
	}
	
	char_type quote() const
	/// The quote character().
	{
	    return m_ctype->quote();
    }

	char_type delimiter() const
	/// The delimiter character.
	{
        return m_ctype->delimiter();
    }

	char_type carriage_return() const
	/// The new line character.
	{
	    return m_ctype->carriage_return();
    }

	char_type newline() const
	/// The new line character.
	{
	    return m_ctype->newline();
    }

	
    bool delimit() const
	/// Returns true if the delimiter character will be detected.
	{
        return m_ctype->delimit();
    }
	
    void delimit(bool value)
	/// Set the detection of the delimiting character on or off.
	{
        m_ctype->delimit(value);
    }

	int_type skip_field()
	/// Skip a field.
	/// \return The next available character.
	{
    	int_type nl = Traits::to_int_type(this->newline());
		int_type ch;
		while((ch = readFromDevice()) != traits_type::eof()) {
			if(delimit() && (ch == Delimiter || ch == nl))
				break;
		}
		return m_is->peek();
	}

	int_type skip_line()
	/// Skip the rest of a line.
	/// \return The next available character.
	{
    	int_type nl = Traits::to_int_type(this->newline());
		int_type ch;
		while((ch = readFromDevice()) != traits_type::eof()) {
			if(delimit() && ch == nl)
				break;
		}
		return m_is->peek();
	}
	
	bool skip_line(char_type prefix)
	/// Match the next character with the prefix character and skip that
	/// character and the rest of a line.
	/// \return True if the prefix character was the next character,
	///         otherwise false.
	{
		int_type ch = m_is->peek();
		if(Traits::to_int_type(prefix) == ch) {
			skip_line();
			return true;
		}
		return false;
	}
	

    private:
	int_type readFromDevice();
	int_type writeToDevice(char_type);

    private:
	std::basic_ios<Char, Traits>& m_ios;
	std::basic_istream<Char, Traits>* m_is;
	std::basic_ostream<Char, Traits>* m_os;
	int m_state;
	DelimiterCType<Char, Delimiter>* m_ctype;
};

template < typename Char, Char Delimiter, typename Traits>
BasicDelimiterBuffer<Char, Delimiter, Traits>::BasicDelimiterBuffer(
	std::basic_ios<Char, Traits>& ios,
	std::basic_istream<Char, Traits>& is)
:   m_ios(ios), m_is(&is), m_os(0), m_state(0), m_ctype(0)
{}

template < typename Char, Char Delimiter, typename Traits>
BasicDelimiterBuffer<Char, Delimiter, Traits>::BasicDelimiterBuffer(
	std::basic_ios<Char, Traits>& ios,
	std::basic_ostream<Char, Traits>& os)
:   m_ios(ios), m_is(0), m_os(&os), m_state(0), m_ctype(0)
{}

template < typename Char, Char Delimiter, typename Traits>
typename BasicDelimiterBuffer<Char, Delimiter, Traits>::int_type
BasicDelimiterBuffer<Char, Delimiter, Traits>::readFromDevice()
{
	int_type ch;
    int_type cr = Traits::to_int_type(this->carriage_return());
    int_type nl = Traits::to_int_type(this->newline());
    int_type qt = Traits::to_int_type(this->quote());

	// End of File
	if(! m_is || (ch = m_is->get()) == traits_type::eof())
        return traits_type::eof();

	// std::cout << traits_type::to_char_type(ch) << std::endl;
	
	// Imbue character classification
    if(! m_ctype) {
		m_ctype = new DelimiterCType<Char, Delimiter>;
        m_ios.imbue(std::locale(m_ios.getloc(), m_ctype));
	}
	
    // Quoting
    if(m_state & Quoting) {
        if(ch == qt) {
            ch = m_is->get();
            if(ch == qt) {
                // A pair of double quotes - keep one of them.
            }
            else {
                // End quoting.
                m_state &= ~Quoting;
                delimit(true);
            }
        }
    }
    else if(ch == qt) {
        ch = m_is->get();
        if(ch == qt) {
            // A pair of double quotes - return an empty character.
            ch = 0;
        }
        else {
            // Start quoting.
            m_state |= Quoting;
            delimit(false);
        }
    }
	// Carriage Return
    else if(ch == cr) {
		int_type peek = m_is->peek();
        if(peek == nl) {
        	m_is->get();
			ch = nl;
        }
        // Otherwise a carriage return without following new line character.
    }
	return ch;
}

template < typename Char, Char Delimiter, typename Traits>
typename BasicDelimiterBuffer<Char, Delimiter, Traits>::int_type
BasicDelimiterBuffer<Char, Delimiter, Traits>::writeToDevice(char_type c)
{
	if(! m_os) return Traits::eof();

    m_os->put(c);
    return Traits::to_int_type(c);
}


// BasicDelimiterInputStream
//=============================================================================

template < typename Char, Char Delimiter, typename Traits = std::char_traits<Char> >
class BasicDelimiterInputStream	: public std::basic_istream<Char, Traits>
/// An input stream having values separated by the delimiter character.
{
    protected:
   	typedef std::basic_istream<Char, Traits> Base;

    public:
	typedef typename Base::char_type char_type;
	typedef typename Base::int_type int_type;
	typedef typename Base::pos_type pos_type;
	typedef typename Base::off_type off_type;
	typedef typename Base::traits_type traits_type;
	typedef BasicDelimiterInputStream& (*manipulator)(BasicDelimiterInputStream&);

	explicit BasicDelimiterInputStream(std::basic_istream<Char, Traits>&);
	/// Creates a BasicDelimiterInputStream and connects it to the given input
	/// stream.

	BasicDelimiterBuffer<Char, Delimiter, Traits>* rdbuf()
	/// The unbuffered stream_buffer.
	{
        return &m_buf;
    }

	std::basic_istream<Char, Traits>& istream()
	/// The attached input stream.
	{
	    return *m_buf.istream();
	}

	char_type quote() const
	/// The quote character().
	{
	    return m_buf.quote();
    }

	char_type delimiter() const
	/// The delimiter character.
	{
        return Delimiter;
    }

	char_type carriage_return() const
	/// The carriage return character.
	{
	    return m_buf.carriage_return();
    }

	char_type newline() const
	/// The new line character.
	{
	    return m_buf.newline();
    }

	
	void skip_field()
	/// Skip the next field.
	{
	    m_buf.skip_field();
	}
	
	void skip_line()
	/// Skip the rest of a line.
	{
	    m_buf.skip_line();
	}

	bool skip_line(char_type prefix)
	/// Match the next character with the prefix character and skip that
	/// character and the rest of a line.
	/// \return True if the prefix character was the next character,
	///         otherwise false.
	{
	    return m_buf.skip_line(prefix);
	}
	
	
	private:
	BasicDelimiterBuffer<Char, Delimiter, Traits> m_buf;
};

template <typename Char, Char Delimiter, typename Traits>
BasicDelimiterInputStream<Char, Delimiter, Traits>::
BasicDelimiterInputStream(std::basic_istream<Char, Traits>& is)
:   Base(&m_buf), m_buf(*this, is)
{}

template <typename Char, Char Delimiter, typename Traits>
inline BasicDelimiterInputStream<Char, Delimiter, Traits>&
operator >> (BasicDelimiterInputStream<Char, Delimiter, Traits>& stream,
	typename BasicDelimiterInputStream<Char, Delimiter, Traits>::manipulator manip)
{
	return manip(stream);
}


template <typename Char, Char Delimiter, typename Traits>
inline BasicDelimiterInputStream<Char, Delimiter, Traits>&
skip(BasicDelimiterInputStream<Char, Delimiter, Traits>& is)
/// A manipulator to skip the next field in the input stream.
/// \see BasicDelimiterInputStream::skip_field()
{
	is.skip_field();
	return is;
}


// BasicDelimiterOutputStream
//=============================================================================

template < typename Char, Char Delimiter, typename Traits = std::char_traits<Char> >
class Foundation_API BasicDelimiterOutputStream
    : public std::basic_ostream<Char, Traits>
/// An output stream for writing values separated by the delimiter character.
{
    protected:
   	typedef std::basic_ostream<Char, Traits> Base;

    public:
	typedef typename Base::char_type char_type;
	typedef typename Base::int_type int_type;
	typedef typename Base::pos_type pos_type;
	typedef typename Base::off_type off_type;
	typedef typename Base::traits_type traits_type;

	typedef void (*Manipulator)(BasicDelimiterOutputStream&);

    public:
	BasicDelimiterOutputStream(std::basic_ostream<Char, Traits>& os);
	/// Creates a BasicDelimiterOutputStream and connects it to the given
	/// output stream.

	std::basic_ostream<Char, Traits>& ostream() const
	/// The attached output stream.
	{
	    return *m_buf.ostream();
	}

	char_type quote() const
	/// The quote character().
	{
	    return m_buf.quote();
    }

	char_type delimiter() const
	/// The delimiter character.
	{
        return Delimiter;
    }

	char_type carriage_return() const
	/// The carriage return character.
	{
	    return m_buf.carriage_return();
    }

	char_type newline() const
	/// The new line character.
	{
	    return m_buf.newline();
    }

	
    int_type put_delimiter() {
	/// Put a separtor into the stream.
        return m_buf.sputc(Delimiter);
    }

    int_type put_quote()
	/// Put a double quote into the stream.
	{
        return m_buf.sputc(quote());
    }
	
	private:
	BasicDelimiterBuffer<Char, Delimiter, Traits> m_buf;
};


template <typename Char, Char Delimiter, typename Traits>
BasicDelimiterOutputStream<Char, Delimiter, Traits>::
BasicDelimiterOutputStream(std::basic_ostream<Char, Traits>& os)
:   Base(&m_buf), m_buf(*this, os)
{}



// DelimiterQuote
//=============================================================================

template <typename T>
struct DelimiterQuote;
/// Quoting strings by putting double quotes around a string and replacing
/// every double quote inside the string by a pair of double quotes.
/// \note Only implementations for std::basic_string, pointers and arrays are
///       provided.

template < typename Char>
struct DelimiterQuote< std::basic_string<Char> >
{
    const std::basic_string<Char>& str;
    DelimiterQuote(const std::basic_string<Char>& s) : str(s) {}
    template <Char Delimiter, typename Traits >
    void apply(BasicDelimiterOutputStream<Char, Delimiter, Traits> & os) const {
        os.put_quote();
        typename std::basic_string<Char>::const_iterator begin = str.begin();
        typename std::basic_string<Char>::const_iterator end = str.end();
        while(begin != end) {
            if(*begin == os.quote()) os.put_quote();
            os.put(*begin++);
        }
        os.put_quote();
    }
};

template <typename Char>
struct DelimiterQuote<Char*>
{
    const Char* str;
    DelimiterQuote(const Char* s) : str(s) {}
    template <Char Delimiter, typename Traits >
    void apply(BasicDelimiterOutputStream<Char, Delimiter, Traits> & os) const {
        os.put_quote();
        const Char* s = str;
        while(*s) {
            if(*s == os.quote()) os.put_quote();
            os.put(*s++);
        }
        os.put_quote();
    }
};

template <typename Char, std::size_t N>
struct DelimiterQuote<Char[N]>
{
    const Char* str;
    DelimiterQuote(const Char* s) : str(s) {}
    template <Char Delimiter, typename Traits >
    void apply(BasicDelimiterOutputStream<Char, Delimiter, Traits> & os) const {
        os.put_quote();
        std::size_t n = N;
        const Char* s = str;
        while(n--) {
            if(*s == os.quote()) os.put_quote();
            os.put(*s++);
        }
        os.put_quote();
    }
};


// quote
//=============================================================================

template <typename T>
inline DelimiterQuote<T> quote(const T& value)
/// A manipulator which constructs a DelimiterQuote.
/// \example const char* hello = "hello"; stream << qoute(hello);
{
    return DelimiterQuote<T>(value);
}


// Operator << for DelimiterQuote
//=============================================================================

template < typename Char, Char Delimiter, typename Traits, typename T>
inline BasicDelimiterOutputStream<Char, Delimiter, Traits>& operator << (
    BasicDelimiterOutputStream<Char, Delimiter, Traits>& os,
	const DelimiterQuote<T>& quote)
/// Write a quoted value.
{
    quote.apply(os);
    return os;
}


// Operator ,
//=============================================================================

template < typename Char, Char Delimiter, typename Traits, typename T>
inline BasicDelimiterOutputStream<Char, Delimiter, Traits>& operator , (
    BasicDelimiterOutputStream<Char, Delimiter, Traits>& os, const T& value)
/// Write a delimiter (usually a ',') and the value.
{
    os.put_delimiter();
    os << value;
    return os;
}


// CsvInputStream and CsvOutputStream
// ============================================================================

typedef BasicDelimiterInputStream<char, ','> CsvInputStream;
/// The type definition of a CSV input stream.

typedef BasicDelimiterOutputStream<char, ','> CsvOutputStream;
/// The type definition of a CSV output stream.

} // namespace Poco
#endif
